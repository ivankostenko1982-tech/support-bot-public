#!/usr/bin/env python3
from __future__ import annotations

import os, time, sqlite3, asyncio, logging, html, hmac, re, platform
from dataclasses import dataclass
from contextlib import closing
from typing import Optional, List, Tuple, Set
from datetime import datetime, timedelta

from aiogram import Bot, Dispatcher, F, Router
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode, ChatType, ChatMemberStatus
from aiogram.filters import CommandStart, Command
from aiogram.types import (
    ChatJoinRequest, Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton,
    ChatMemberAdministrator, ChatMemberOwner, ChatMember, ChatPermissions, ChatMemberUpdated
)
from aiogram.utils.keyboard import InlineKeyboardBuilder

# Optional systemd watchdog
try:
    from sdnotify import SystemdNotifier  # type: ignore
except Exception:  # pragma: no cover
    SystemdNotifier = None  # type: ignore

# â”€â”€ Meta / version â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
APP_NAME = "support-join-guard"
APP_VERSION = os.getenv("APP_VERSION", "2.1.0")  # bump when logic changes
START_MONO = time.monotonic()
START_TS = int(time.time())

# â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()
_numeric_level = getattr(logging, _LOG_LEVEL, logging.INFO)
logging.basicConfig(level=_numeric_level, format="%(asctime)s | %(levelname)s | %(name)s | %(message)s")
log = logging.getLogger(APP_NAME)

# â”€â”€ ENV helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _get_env_int(key: str, default: int) -> int:
    raw = os.getenv(key)
    if raw is None or raw.strip() == "":
        return int(default)
    try:
        return int(raw.strip())
    except Exception:
        raise SystemExit(f"ENV {key} must be integer, got: {raw!r}")

def _parse_id_list(raw: str) -> Set[int]:
    ids: Set[int] = set()
    if not raw or not raw.strip():
        return ids
    for token in raw.replace(",", " ").split():
        if "=" in token:
            log.warning("Ignoring non-id token in list: %r", token); continue
        try:
            ids.add(int(token))
        except ValueError:
            log.warning("Skipping malformed ID: %r", token)
    return ids

# â”€â”€ ENV â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BOT_TOKEN = (os.getenv("BOT_TOKEN") or "").strip()
VERIFY_SECRET = (os.getenv("VERIFY_SECRET") or "").strip()
if not BOT_TOKEN:
    raise SystemExit("BOT_TOKEN is required in /etc/tgbots/support.env")
if not VERIFY_SECRET:
    raise SystemExit("VERIFY_SECRET is required in /etc/tgbots/support.env")

JOIN_REQUEST_TTL = _get_env_int("JOIN_REQUEST_TTL", 600)
SQLITE_PATH = os.getenv("SQLITE_PATH", "/opt/tgbots/bots/support/join_guard_state.db")
ENV_DELETE_SYSTEM_MESSAGES = os.getenv("DELETE_SYSTEM_MESSAGES", "false").lower() in {"1","true","yes","on"}
EXPIRE_SWEEP_INTERVAL = _get_env_int("EXPIRE_SWEEP_INTERVAL", 20)
ADMIN_CONTACT_OVERRIDE = (os.getenv("ADMIN_CONTACT_OVERRIDE") or "").strip().lstrip("@")
NEWCOMER_WINDOW_SECONDS = _get_env_int("NEWCOMER_WINDOW_SECONDS", 24*60*60)
ENV_LOCKDOWN_NONADMIN_BOTS = os.getenv("LOCKDOWN_NONADMIN_BOTS", "true").lower() in {"1","true","yes","on"}
AGGRESSIVE_CHANNEL_ANTILINK = os.getenv("AGGRESSIVE_CHANNEL_ANTILINK", "false").lower() in {"1","true","yes","on"}

log.info(
    "BOOT: app.py loaded file=%s SQLITE_PATH=%s WINDOW=%s",
    __file__, SQLITE_PATH if "SQLITE_PATH" in globals() else os.getenv("SQLITE_PATH"),
    os.getenv("NEWCOMER_WINDOW_SECONDS","86400")
)

ALLOWLIST = _parse_id_list(os.getenv("TARGET_CHAT_IDS", "")) | _parse_id_list(os.getenv("TARGET_CHAT_ID", ""))
if ALLOWLIST:
    log.info("Allowlist enabled for chat_ids=%s", sorted(ALLOWLIST))
else:
    log.info("Allowlist is empty â€” bot will accept join requests from ANY chat")

ADMIN_IDS = _parse_id_list(os.getenv("ADMIN_IDS", ""))
if ADMIN_IDS:
    log.info("Static admin ids set: %s", sorted(ADMIN_IDS))

# â”€â”€ Bot/Dispatcher/Router â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()

# ĞÑ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ñ€Ğ¾ÑƒÑ‚ĞµÑ€ Ğ´Ğ»Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´ â€” Ğ²Ñ‹ÑˆĞµ Ğ¿Ğ¾ Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚Ñƒ
cmd_router = Router(name="commands")
dp.include_router(cmd_router)

router = Router(name="main")
dp.include_router(router)

# â”€â”€ App State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@dataclass
class AppState:
    sys_clean_enabled: bool = False
    me_id: Optional[int] = None
    me_username: Optional[str] = None
    botlock_enabled: bool = True
    diag_enabled: bool = False  # toggle via /diag

state = AppState()

# â”€â”€ SQLite â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
db_dir = os.path.dirname(SQLITE_PATH) or "."
os.makedirs(db_dir, exist_ok=True)

def init_db() -> None:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        cur = conn.cursor()
        cur.execute("PRAGMA journal_mode=WAL;")
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS pending_requests (
                user_id      INTEGER NOT NULL,
                chat_id      INTEGER NOT NULL,
                chat_title   TEXT,
                requested_at INTEGER NOT NULL,
                PRIMARY KEY (user_id, chat_id)
            )
            """
        )
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS settings (
                key   TEXT PRIMARY KEY,
                value TEXT NOT NULL
            )
            """
        )
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS approvals (
                user_id     INTEGER NOT NULL,
                chat_id     INTEGER NOT NULL,
                approved_at INTEGER NOT NULL,
                PRIMARY KEY (user_id, chat_id)
            )
            """
        )
        conn.commit()

def db_get_setting(key: str) -> Optional[str]:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        cur = conn.execute("SELECT value FROM settings WHERE key=?", (key,))
        row = cur.fetchone()
        return row[0] if row else None

def db_set_setting(key: str, value: str) -> None:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        conn.execute(
            "INSERT INTO settings(key,value) VALUES(?,?) "
            "ON CONFLICT(key) DO UPDATE SET value=excluded.value",
            (key, value),
        )
        conn.commit()

def set_pending(user_id: int, chat_id: int, chat_title: str) -> None:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        conn.execute(
            """
            INSERT INTO pending_requests(user_id, chat_id, chat_title, requested_at)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(user_id, chat_id) DO UPDATE SET
                chat_title=excluded.chat_title,
                requested_at=excluded.requested_at
            """,
            (user_id, chat_id, chat_title, int(time.time())),
        )
        conn.commit()

def clear_pending(user_id: int, chat_id: int) -> None:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        conn.execute("DELETE FROM pending_requests WHERE user_id=? AND chat_id=?", (user_id, chat_id))
        conn.commit()

def record_approval(user_id: int, chat_id: int) -> None:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        conn.execute(
            """
            INSERT INTO approvals(user_id, chat_id, approved_at)
            VALUES (?, ?, ?)
            ON CONFLICT(user_id, chat_id) DO UPDATE SET
                approved_at=excluded.approved_at
            """,
            (user_id, chat_id, int(time.time())),
        )
        conn.commit()

def newcomer_until(user_id: int, chat_id: int) -> Optional[int]:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        cur = conn.execute("SELECT approved_at FROM approvals WHERE user_id=? AND chat_id=?", (user_id, chat_id))
        row = cur.fetchone()
        if not row:
            return None
        return row[0] + NEWCOMER_WINDOW_SECONDS

def ensure_newcomer_window(user_id: int, chat_id: int) -> int:
    """
    Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµÑ‚ timestamp ĞºĞ¾Ğ½Ñ†Ğ° Ğ¾ĞºĞ½Ğ° Ğ½Ğ¾Ğ²Ğ¸Ñ‡ĞºĞ°. Ğ•ÑĞ»Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸ Ğ½ĞµÑ‚ â€” ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ ĞµÑ‘ Ğ½Ğ° 'ÑĞµĞ¹Ñ‡Ğ°Ñ'.
    """
    until = newcomer_until(user_id, chat_id)
    if until is None:
        record_approval(user_id, chat_id)
        until = newcomer_until(user_id, chat_id) or int(time.time())
    return int(until)

def is_newcomer(user_id: int, chat_id: int) -> bool:
    until = newcomer_until(user_id, chat_id)
    return bool(until and until > int(time.time()))

# â”€â”€ Admin & bot rights checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def _get_chat_member_safe(chat_id: int, user_id: int) -> Optional['ChatMember']:
    try:
        return await bot.get_chat_member(chat_id, user_id)
    except Exception as e:
        log.debug("get_chat_member failed chat=%s uid=%s: %s", chat_id, user_id, e)
        return None

def _is_admin_cm(cm: Optional['ChatMember']) -> bool:
    return isinstance(cm, (ChatMemberAdministrator, ChatMemberOwner))

async def is_user_admin(user_id: Optional[int], chat_id_context: Optional[int] = None) -> bool:
    if user_id is None:
        return False
    if user_id in ADMIN_IDS:
        return True
    if chat_id_context is not None:
        cm = await _get_chat_member_safe(chat_id_context, user_id)
        if _is_admin_cm(cm):
            return True
    return False

async def log_bot_rights(chat_id: int) -> None:
    try:
        me = await bot.get_me()
        cm = await _get_chat_member_safe(chat_id, me.id)
        if cm is None:
            log.warning("BOT-RIGHTS: cannot read bot ChatMember in chat=%s", chat_id)
            return
        role = getattr(cm, "status", "unknown")
        can_send = True
        if role == "restricted":
            perms = getattr(cm, "permissions", None)
            if isinstance(perms, ChatPermissions):
                can_send = bool(getattr(perms, "can_send_messages", False))
        log.info("BOT-RIGHTS: chat=%s role=%s can_send=%s", chat_id, role, can_send)
        if not can_send:
            log.warning("BOT-RIGHTS: bot cannot send messages to chat=%s â€” Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ¿Ñ€Ğ°Ğ²Ğ°/Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ñ", chat_id)
    except Exception as e:
        log.debug("BOT-RIGHTS: failed for chat=%s: %s", chat_id, e)

async def ensure_admin(m: 'Message') -> bool:
    chat_id_ctx = m.chat.id if m.chat else None
    user_id = m.from_user.id if m.from_user else None
    sender_chat_id = m.sender_chat.id if m.sender_chat else None
    if chat_id_ctx:
        await log_bot_rights(chat_id_ctx)
    if sender_chat_id and chat_id_ctx and sender_chat_id == chat_id_ctx:
        return True
    ok = await is_user_admin(user_id, chat_id_ctx)
    log.debug("ensure_admin: chat=%s uid=%s -> %s", chat_id_ctx, user_id, ok)
    return ok

# â”€â”€ HMAC helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _sig16(payload: str) -> str:
    import hashlib
    mac = hmac.new(VERIFY_SECRET.encode('utf-8'), payload.encode('utf-8'), digestmod=hashlib.sha256).digest()
    return mac[:8].hex()

def build_verify_cbdata(chat_id: int, user_id: int) -> str:
    ts = int(time.time())
    core = f"{chat_id}:{user_id}:{ts}"
    sig = _sig16(core)
    return f"v:{chat_id}:{ts}:{sig}"

def parse_and_verify_cbdata(cbdata: str, actual_user_id: int) -> tuple[bool, Optional[int], Optional[str]]:
    if not cbdata.startswith("v:"):
        return (False, None, "ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ")
    try:
        _, chat_id_s, ts_s, sig = cbdata.split(":", 3)
        chat_id = int(chat_id_s); ts = int(ts_s)
    except Exception:
        return (False, None, "ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ")
    if int(time.time()) - ts > JOIN_REQUEST_TTL + 30:
        return (False, None, "Ğ’Ñ€ĞµĞ¼Ñ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ğ¸ÑÑ‚ĞµĞºĞ»Ğ¾")
    core = f"{chat_id}:{actual_user_id}:{ts}"
    if _sig16(core) != sig:
        return (False, None, "ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑÑŒ Ğ½Ğµ ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ")
    return (True, chat_id, None)

# â”€â”€ UI helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def verify_keyboard(chat_id: int, user_id: int) -> 'InlineKeyboardMarkup':
    kb = InlineKeyboardBuilder()
    kb.button(text="âœ… Ğ¯ Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞº (Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ)", callback_data=build_verify_cbdata(chat_id, user_id))
    kb.button(text="ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="refresh")
    return kb.as_markup()

def requests_keyboard(user_id: int, requests: List[Tuple[int, str, int]]) -> 'InlineKeyboardMarkup':
    kb = InlineKeyboardBuilder()
    for chat_id, chat_title, _ in requests:
        label = f"ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ğ² Â«{chat_title or chat_id}Â»"
        kb.button(text=label, callback_data=build_verify_cbdata(chat_id, user_id))
    kb.button(text="ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="refresh")
    return kb.as_markup()

async def get_public_admin_mention(chat_id: int) -> Optional[str]:
    if ADMIN_CONTACT_OVERRIDE:
        uname = ADMIN_CONTACT_OVERRIDE
        return f'<a href="https://t.me/{uname}">@{uname}</a>'
    try:
        admins: List['ChatMember'] = await bot.get_chat_administrators(chat_id)
    except Exception as e:
        log.debug("get_chat_administrators failed for chat %s: %s", chat_id, e)
        return None
    for cm in admins:
        try:
            is_admin = isinstance(cm, (ChatMemberAdministrator, ChatMemberOwner))
            if not is_admin:
                continue
            if isinstance(cm, ChatMemberAdministrator) and getattr(cm, "is_anonymous", False):
                continue
            user = getattr(cm, "user", None)
            if not user or user.is_bot:
                continue
            uname = user.username
            if not uname:
                continue
            return f'<a href="https://t.me/{uname}">@{uname}</a>'
        except Exception:
            continue
    return None

async def get_group_open_url(chat_id: int) -> Optional[str]:
    try:
        chat = await bot.get_chat(chat_id)
        if getattr(chat, "username", None):
            return f"https://t.me/{chat.username}"
    except Exception as e:
        log.debug("get_chat failed for %s: %s", chat_id, e)
    try:
        expire = int((datetime.utcnow() + timedelta(minutes=30)).timestamp())
        link = await bot.create_chat_invite_link(
            chat_id=chat_id,
            name="auto-open",
            expire_date=expire,
            member_limit=1,
            creates_join_request=False,
        )
        return link.invite_link
    except Exception as e:
        log.debug("create_chat_invite_link failed for %s: %s", chat_id, e)
        return None

def open_group_keyboard(url: str, title: Optional[str] = None) -> 'InlineKeyboardMarkup':
    kb = InlineKeyboardBuilder()
    kb.add(InlineKeyboardButton(text=title or "ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ", url=url))
    return kb.as_markup()

# â”€â”€ Filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
group_msg_filter = (F.chat.type == ChatType.SUPERGROUP) | (F.chat.type == ChatType.GROUP)

# === Newcomer hard gate: delete ANY message within window and notify ===
async def _notify_newcomer_user(user_id: int, window_seconds: int, chat_title: str | None):
    try:
        hours = max(1, int(window_seconds // 3600))
        txt = (
            f"âš ï¸ ĞĞ½Ñ‚Ğ¸ÑĞ¿Ğ°Ğ¼: Ğ² Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞ¸Ğµ {hours} Ñ‡. Ğ²Ğ°ÑˆĞ¸ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ "
            + (f"Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ Â«{chat_title}Â» " if chat_title else "Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ğµ ")
            + "Ğ±ÑƒĞ´ÑƒÑ‚ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ÑƒĞ´Ğ°Ğ»ÑÑ‚ÑŒÑÑ. Ğ­Ñ‚Ğ¾ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ ÑĞ¿Ğ°Ğ¼Ğ° Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ñ‹Ñ… ÑƒÑ‡Ğ°ÑÑ‚Ğ½Ğ¸ĞºĞ¾Ğ²."
        )
        await bot.send_message(user_id, txt, disable_web_page_preview=True)
        log.info("AntiSpam(Newcomer): DM sent to user uid=%s", user_id)
    except Exception as e:
        log.debug("AntiSpam(Newcomer): DM to user uid=%s failed: %s", user_id, e)

async def _notify_admins_about_deletion(chat_id: int, user_id: int, username: str | None, chat_title: str | None):
    try:
        admins = await bot.get_chat_administrators(chat_id)
    except Exception as e:
        log.debug("AntiSpam(Newcomer): get_chat_administrators failed chat=%s err=%s", chat_id, e)
        return
    uref = f"@{username}" if username else str(user_id)
    ctitle = f"Â«{chat_title}Â»" if chat_title else str(chat_id)
    msg = f"ğŸ§¹ AntiSpam: ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ñƒ Ğ½Ğ¾Ğ²Ğ¸Ñ‡ĞºĞ° {uref} Ğ² Ñ‡Ğ°Ñ‚Ğµ {ctitle}. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚ÑŒ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ."
    for cm in admins:
        u = getattr(cm, "user", None)
        if not u or getattr(u, "is_bot", False):
            continue
        try:
            await bot.send_message(u.id, msg, disable_web_page_preview=True)
        except Exception as e:
            log.debug("AntiSpam(Newcomer): DM to admin %s failed: %s", u.id if u else "-", e)

async def _newcomer_delete_and_notify(m: 'Message'):
    if ALLOWLIST and int(m.chat.id) not in ALLOWLIST:
        return
    u = m.from_user
    if not u or u.is_bot:
        return
    # Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ² Ğ½Ğµ Ñ‚Ñ€Ğ¾Ğ³Ğ°ĞµĞ¼
    if await is_user_admin(u.id, m.chat.id):
        return
    # Ğ¾Ğ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ğ¼ Ğ¾ĞºĞ½Ğ¾ Ğ½Ğ¾Ğ²Ğ¸Ñ‡ĞºĞ° Ğ´Ğ°Ğ¶Ğµ ĞµÑĞ»Ğ¸ Ğ½Ğµ Ğ¿Ñ€Ğ¸ÑˆÑ‘Ğ» chat_member
    until = ensure_newcomer_window(u.id, m.chat.id)
    if until <= int(time.time()):
        return
    chat_title = getattr(m.chat, "title", None)
    try:
        await m.delete()
        log.info("AntiSpam(Newcomer): deleted ANY msg chat=%s mid=%s uid=%s", m.chat.id, m.message_id, u.id)
    except Exception as e:
        log.warning("AntiSpam(Newcomer): delete failed chat=%s mid=%s err=%s", m.chat.id, m.message_id, e)
        return
    # notifications (best-effort)
    try:
        await _notify_newcomer_user(u.id, NEWCOMER_WINDOW_SECONDS, chat_title)
    except Exception:
        pass
    try:
        await _notify_admins_about_deletion(m.chat.id, u.id, getattr(u, "username", None), chat_title)
    except Exception:
        pass

@router.message(group_msg_filter)
async def newcomer_gate_delete_all(m: 'Message'):
    await _newcomer_delete_and_notify(m)

@router.edited_message(group_msg_filter)
async def newcomer_gate_delete_all_edited(m: 'Message'):
    await _newcomer_delete_and_notify(m)

def _has_bot_command(m: 'Message') -> bool:
    for e in (m.entities or []) + (m.caption_entities or []):
        if getattr(e, "type", None) == "bot_command":
            return True
    return False

# â”€â”€ Command handlers (PRIORITY router) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _log_cmd_ignored(m: 'Message', cmd: str):
    uid = m.from_user.id if m.from_user else None
    uname = f"@{m.from_user.username}" if (m.from_user and m.from_user.username) else "-"
    log.info("CMD %s ignored: user is not admin in chat=%s uid=%s %s", cmd, getattr(m.chat, "id", None), uid, uname)

@cmd_router.message(Command("health"))
async def health(m: 'Message'):
    log.debug("HEALTH handler entered: chat=%s uid=%s", getattr(m.chat, "id", None), getattr(m.from_user, "id", None))
    if not await ensure_admin(m):
        _log_cmd_ignored(m, "/health")
        return
    if m.chat:
        await log_bot_rights(m.chat.id)
    await m.answer("ok")

@cmd_router.message(Command("ping"))
async def ping(m: 'Message'):
    if not await ensure_admin(m):
        _log_cmd_ignored(m, "/ping"); return
    t0 = time.monotonic()
    try:
        await bot.get_me()
    except Exception:
        pass
    dt = int((time.monotonic() - t0)*1000)
    await m.answer(f"pong {dt}ms")

@cmd_router.message(Command("version"))
async def version_cmd(m: 'Message'):
    if not await ensure_admin(m):
        _log_cmd_ignored(m, "/version"); return
    import aiogram
    uptime = int(time.monotonic() - START_MONO)
    up_h = uptime // 3600
    up_m = (uptime % 3600) // 60
    up_s = uptime % 60
    await m.answer(
        "ğŸ§© Ğ’ĞµÑ€ÑĞ¸Ñ Ğ±Ğ¾Ñ‚Ğ°\n"
        f"- app: {APP_NAME} {APP_VERSION}\n"
        f"- aiogram: {aiogram.__version__}\n"
        f"- python: {platform.python_version()}\n"
        f"- uptime: {up_h:02d}:{up_m:02d}:{up_s:02d}\n"
        f"- sys_clean: {state.sys_clean_enabled}\n"
        f"- botlock: {state.botlock_enabled}\n"
        f"- diag: {state.diag_enabled}"
    )

@cmd_router.message(Command("allowlist"))
async def allowlist_cmd(m: 'Message'):
    if not await ensure_admin(m):
        _log_cmd_ignored(m, "/allowlist"); return
    if ALLOWLIST:
        await m.answer("Ğ Ğ°Ğ·Ñ€ĞµÑˆÑ‘Ğ½Ğ½Ñ‹Ğµ chat_id:\n" + "\n".join(str(i) for i in sorted(ALLOWLIST)))
    else:
        await m.answer("Ğ Ğ°Ğ·Ñ€ĞµÑˆÑ‘Ğ½Ğ½Ñ‹Ğµ chat_id Ğ½Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½Ñ‹ (Ğ±Ğ¾Ñ‚ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ¸Ğ· Ğ»ÑĞ±Ñ‹Ñ… Ñ‡Ğ°Ñ‚Ğ¾Ğ²).")

@cmd_router.message(Command("sysclean"))
async def sysclean_cmd(m: 'Message'):
    if not await ensure_admin(m):
        _log_cmd_ignored(m, "/sysclean"); return
    parts = (m.text or "").split()
    if len(parts) == 1:
        origin = "override(Ğ‘Ğ”)" if db_get_setting("sysclean_enabled") is not None else "env"
        await m.answer(
            "ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ ÑĞµĞ¹Ñ‡Ğ°Ñ "
            f"{'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if state.sys_clean_enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'} "
            f"(Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº: {origin}).\n"
            "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: /sysclean on  Ğ¸Ğ»Ğ¸  /sysclean off"
        ); return
    arg = parts[1].strip().lower()
    if arg in {"on", "off"}:
        enabled = (arg == "on")
        db_set_setting("sysclean_enabled", "true" if enabled else "false")
        state.sys_clean_enabled = enabled
        await m.answer(
            "Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾. ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ "
            f"{'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'} (ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾, Ğ¿ĞµÑ€ĞµĞ¶Ğ¸Ğ²Ñ‘Ñ‚ Ñ€ĞµÑÑ‚Ğ°Ñ€Ñ‚)."
        )

@cmd_router.message(Command("botlock"))
async def botlock_cmd(m: 'Message'):
    if not await ensure_admin(m):
        _log_cmd_ignored(m, "/botlock"); return
    parts = (m.text or "").split()
    if len(parts) == 1:
        origin = "override(Ğ‘Ğ”)" if db_get_setting("botlock_enabled") is not None else "env"
        await m.answer(
            "Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ½Ğµ-Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ±Ğ¾Ñ‚Ğ¾Ğ² ÑĞµĞ¹Ñ‡Ğ°Ñ "
            f"{'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if state.botlock_enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'} "
            f"(Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº: {origin}).\n"
            "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: /botlock on  Ğ¸Ğ»Ğ¸  /botlock off"
        ); return
    arg = parts[1].strip().lower()
    if arg in {"on", "off"}:
        enabled = (arg == "on")
        db_set_setting("botlock_enabled", "true" if enabled else "false")
        state.botlock_enabled = enabled
        await m.answer(
            "Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾. Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ½Ğµ-Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ±Ğ¾Ñ‚Ğ¾Ğ² Ñ‚ĞµĞ¿ĞµÑ€ÑŒ "
            f"{'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'} (ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾, Ğ¿ĞµÑ€ĞµĞ¶Ğ¸Ğ²Ñ‘Ñ‚ Ñ€ĞµÑÑ‚Ğ°Ñ€Ñ‚)."
        )

@cmd_router.message(Command("diag"))
async def diag_cmd(m: 'Message'):
    if not await ensure_admin(m):
        _log_cmd_ignored(m, "/diag"); return
    parts = (m.text or "").split()
    if len(parts) == 1:
        await m.answer(
            "Ğ”Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ° Ğ»Ğ¾Ğ³Ğ¾Ğ² ÑĞµĞ¹Ñ‡Ğ°Ñ "
            f"{'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if state.diag_enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'}.\n"
            "Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: /diag on | /diag off"
        ); return
    arg = parts[1].strip().lower()
    if arg in {"on", "off"}:
        enabled = (arg == "on")
        db_set_setting("diag_enabled", "true" if enabled else "false")
        state.diag_enabled = enabled
        await m.answer(f"Ğ”Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ° Ğ»Ğ¾Ğ³Ğ¾Ğ² {'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'} (ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾).")

# Ğ¡Ñ‚Ñ€Ğ°Ñ…Ğ¾Ğ²ĞºĞ°: ĞµÑĞ»Ğ¸ Ğ¿Ğ¾ ĞºĞ°ĞºĞ¾Ğ¹-Ñ‚Ğ¾ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ğµ Command(...) Ğ½Ğµ ÑÑ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ»
@cmd_router.message(group_msg_filter)
async def _health_text_alias(m: 'Message'):
    t = (m.text or "").strip()
    if not t.startswith("/"):
        return
    uname = (state.me_username or "").lower() if hasattr(state, "me_username") else ""
    head = t.split()[0].lower()
    variants = {"/health", f"/health@{uname}"} if uname else {"/health"}
    if head in variants:
        await health(m)

# Ğ”Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ»Ğ¾Ğ³Ğ³ĞµÑ€ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´
@cmd_router.message(group_msg_filter)
async def _log_any_commands(m: 'Message'):
    if not _has_bot_command(m):
        return
    uid = m.from_user.id if m.from_user else None
    uname = f"@{m.from_user.username}" if (m.from_user and m.from_user.username) else "-"
    txt = (m.text or m.caption or "") or ""
    cmds = []
    for e in (m.entities or []) + (m.caption_entities or []):
        if getattr(e, "type", None) == "bot_command":
            try:
                cmds.append(txt[e.offset:e.offset+e.length])
            except Exception:
                pass
    log.info("COMMAND seen: chat=%s uid=%s %s cmds=%s text=%r", getattr(m.chat, "id", None), uid, uname, cmds, txt[:400])

# â”€â”€ Service cleaner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
service_filter = (
    (F.chat.type == ChatType.GROUP) | (F.chat.type == ChatType.SUPERGROUP)
) & (
    F.new_chat_members | F.left_chat_member | F.new_chat_title | F.new_chat_photo |
    F.delete_chat_photo | F.group_chat_created | F.supergroup_chat_created |
    F.migrate_to_chat_id | F.migrate_from_chat_id | F.pinned_message
)

@router.message(service_filter)
async def delete_service_messages(m: 'Message'):
    if not state.sys_clean_enabled:
        return
    if ALLOWLIST and int(m.chat.id) not in ALLOWLIST:
        return
    try:
        await bot.delete_message(chat_id=m.chat.id, message_id=m.message_id)
    except Exception as e:
        logging.debug("delete_message failed in chat %s mid=%s: %s", m.chat.id, m.message_id, e)

# â”€â”€ Bot lockdown â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _zero_perms() -> 'ChatPermissions':
    return ChatPermissions(
        can_send_messages=False,
        can_send_media_messages=False,
        can_send_polls=False,
        can_send_other_messages=False,
        can_add_web_page_previews=False,
        can_change_info=False,
        can_invite_users=False,
        can_pin_messages=False,
        can_manage_topics=False,
    )

async def _restrict_bot_forever(chat_id: int, user_id: int) -> None:
    if not state.botlock_enabled:
        return
    if state.me_id and user_id == state.me_id:
        return
    try:
        cm = await bot.get_chat_member(chat_id, user_id)
        if isinstance(cm, (ChatMemberAdministrator, ChatMemberOwner)):
            return
    except Exception:
        pass
    try:
        now = int(time.time())
        forever_days = 400
        await bot.restrict_chat_member(
            chat_id=chat_id,
            user_id=user_id,
            permissions=_zero_perms(),
            until_date=now + forever_days * 24 * 60 * 60,
        )
        log.info("Bot lockdown: restricted bot user_id=%s in chat_id=%s", user_id, chat_id)
    except Exception as e:
        log.debug("Bot lockdown failed for user_id=%s chat_id=%s: %s", user_id, chat_id, e)

@router.message((F.chat.type.in_({ChatType.GROUP, ChatType.SUPERGROUP})) & F.new_chat_members)
async def on_new_members_lockdown(m: 'Message'):
    for u in (m.new_chat_members or []):
        if u.is_bot:
            await _restrict_bot_forever(m.chat.id, u.id)
        else:
            record_approval(u.id, m.chat.id)

@router.message((F.chat.type.in_({ChatType.GROUP, ChatType.SUPERGROUP})) & F.from_user.as_("u"))
async def on_any_group_message_lock_bots(m: 'Message', u):
    try:
        if u and getattr(u, "is_bot", False):
            await _restrict_bot_forever(m.chat.id, u.id)
    except Exception:
        pass

# â”€â”€ Join Request flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@router.chat_join_request()
async def on_join_request(event: 'ChatJoinRequest'):
    if ALLOWLIST and int(event.chat.id) not in ALLOWLIST:
        log.info("Ignoring join request for non-allowed chat_id=%s title=%s", event.chat.id, event.chat.title)
        return

    set_pending(event.from_user.id, event.chat.id, event.chat.title or "")

    title = event.chat.title or "Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ°"
    open_url = await get_group_open_url(event.chat.id)
    if open_url:
        title_html = f'<a href="{html.escape(open_url, quote=True)}">{html.escape(title)}</a>'
    else:
        title_html = html.escape(title)

    text = (
        f"ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ²ÑÑ‚ÑƒĞ¿Ğ¸Ñ‚ÑŒ Ğ² {title_html}, Ğ¿Ñ€Ğ¾Ğ¹Ğ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºÑƒÑ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ.\n\n"
        "ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ â€” Ğ¸ Ğ²Ñ‹ Ğ±ÑƒĞ´ĞµÑ‚Ğµ Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ñ‹ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸. "
        "Ğ•ÑĞ»Ğ¸ ĞºĞ½Ğ¾Ğ¿ĞºĞ° Ğ½Ğµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚, Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ /start ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·."
    )

    try:
        await bot.send_message(
            chat_id=event.from_user.id,
            text=text,
            reply_markup=verify_keyboard(chat_id=event.chat.id, user_id=event.from_user.id),
            disable_web_page_preview=True,
        )
    except Exception as e:
        log.info("DM failed (maybe user hasn't started bot yet): %s", e)

# â”€â”€ Start & callbacks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@router.message(CommandStart())
async def on_start(message: 'Message'):
    await expire_old_requests()
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        rows = list(conn.execute(
            "SELECT chat_id, chat_title, requested_at FROM pending_requests WHERE user_id=?",
            (message.from_user.id,)
        ))
    if not rows:
        kb = InlineKeyboardBuilder()
        kb.button(text="ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="refresh")
        await message.answer(
            "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! ĞŸĞ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ²ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ.\n"
            "Ğ•ÑĞ»Ğ¸ Ğ²Ñ‹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‡Ñ‚Ğ¾ Ğ½Ğ°Ğ¶Ğ°Ğ»Ğ¸ Â«Ğ’ÑÑ‚ÑƒĞ¿Ğ¸Ñ‚ÑŒÂ», Ğ¿Ğ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸Ñ‚Ğµ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑĞµĞºÑƒĞ½Ğ´ Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Â«ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒÂ».",
            reply_markup=kb.as_markup(),
        )
        return

    if len(rows) == 1:
        chat_id, chat_title, _ = rows[0]
        safe = html.escape(chat_title) if chat_title else str(chat_id)
        await message.answer(
            f"Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ²ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ğ² Â«{safe}Â». ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ.",
            reply_markup=verify_keyboard(chat_id=chat_id, user_id=message.from_user.id),
        )
    else:
        await message.answer(
            "ĞĞ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‡Ğ°Ñ‚ Ğ½Ğ¸Ğ¶Ğµ:",
            reply_markup=requests_keyboard(message.from_user.id, rows),
        )

@router.callback_query(F.data == "refresh")
async def on_refresh(cb: 'CallbackQuery'):
    await expire_old_requests()
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        rows = list(conn.execute(
            "SELECT chat_id, chat_title, requested_at FROM pending_requests WHERE user_id=?",
            (cb.from_user.id,)
        ))
    if not rows:
        try:
            await cb.message.edit_text("Ğ—Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾. Ğ•ÑĞ»Ğ¸ Ğ²Ñ‹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‡Ñ‚Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ, Ğ¿Ğ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸Ñ‚Ğµ Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·.")
        except Exception:
            pass
        await cb.answer("ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾")
        return

    if len(rows) == 1:
        chat_id, chat_title, _ = rows[0]
        safe = html.escape(chat_title) if chat_title else str(chat_id)
        await cb.message.edit_text(
            f"Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ²ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ğ² Â«{safe}Â». ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ.",
            reply_markup=verify_keyboard(chat_id=chat_id, user_id=cb.from_user.id),
        )
        await cb.answer("ĞĞº")
        return

    await cb.message.edit_text(
        "ĞĞ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‡Ğ°Ñ‚ Ğ½Ğ¸Ğ¶Ğµ:",
        reply_markup=requests_keyboard(cb.from_user.id, rows),
    )
    await cb.answer("ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾")

@router.callback_query(F.data.startswith("v:"))
async def on_verify(cb: 'CallbackQuery'):
    ok, chat_id, err = parse_and_verify_cbdata(cb.data, actual_user_id=cb.from_user.id)
    if not ok or chat_id is None:
        await cb.answer(err or "ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True); return

    if ALLOWLIST and chat_id not in ALLOWLIST:
        await cb.answer("Ğ­Ñ‚Ğ° Ğ·Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ¸Ğ· Ñ€Ğ°Ğ·Ñ€ĞµÑˆÑ‘Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ñ‡Ğ°Ñ‚Ğ°.", show_alert=True); return

    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        row = conn.execute(
            "SELECT chat_title, requested_at FROM pending_requests WHERE user_id=? AND chat_id=?",
            (cb.from_user.id, chat_id),
        ).fetchone()

    if not row:
        await cb.answer("Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° Ğ¸Ğ»Ğ¸ ÑƒÑÑ‚Ğ°Ñ€ĞµĞ»Ğ°. ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Â«ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒÂ».", show_alert=True); return

    chat_title, requested_at = row
    chat_title_safe = html.escape(chat_title) if chat_title else str(chat_id)

    if int(time.time()) - int(requested_at) > JOIN_REQUEST_TTL:
        clear_pending(cb.from_user.id, chat_id)
        try:
            await bot.decline_chat_join_request(chat_id=chat_id, user_id=cb.from_user.id)
        except Exception:
            pass
        await cb.answer("Ğ—Ğ°ÑĞ²ĞºĞ° Ğ¿Ñ€Ğ¾ÑÑ€Ğ¾Ñ‡ĞµĞ½Ğ°. ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ĞµÑ‘ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾.", show_alert=True); return

    try:
        await bot.approve_chat_join_request(chat_id=chat_id, user_id=cb.from_user.id)
        record_approval(cb.from_user.id, chat_id)
        clear_pending(cb.from_user.id, chat_id)

        await cb.message.edit_text(f"Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! Ğ—Ğ°ÑĞ²ĞºĞ° Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ğ° â€” Ğ´Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Â«{chat_title_safe}Â».")
        await cb.answer("ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¾ âœ…")

        url = await get_group_open_url(chat_id)
        if url:
            try:
                await bot.send_message(
                    chat_id=cb.from_user.id,
                    text=f"Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ! ĞÑ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ Ñ‡Ğ°Ñ‚ Â«{chat_title_safe}Â»:",
                    reply_markup=open_group_keyboard(url, title=f"ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² Â«{chat_title_safe}Â»"),
                    disable_web_page_preview=True,
                )
            except Exception as e:
                log.debug("DM with open button failed: %s", e)

    except Exception:
        logging.exception("approve_chat_join_request failed")
        await cb.answer("ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ğ´Ğ¾Ğ±Ñ€Ğ¸Ñ‚ÑŒ. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.", show_alert=True)

# â”€â”€ Diagnostics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _brief_entities(m: 'Message'):
    ents = []
    for e in (m.entities or []) + (m.caption_entities or []):
        ents.append(getattr(e, "type", "?"))
    return ",".join(ents) if ents else "-"

def _has_links_or_mentions(m: 'Message') -> bool:
    txt = (m.text or m.caption or "") or ""
    if MENTION_OR_LINK_RE.search(txt):
        return True
    for ent in (m.entities or []) + (m.caption_entities or []):
        if getattr(ent, "type", None) in ("url", "text_link", "mention"):
            return True
    return False

@router.message(group_msg_filter)
async def __diag_log_new(m: 'Message'):
    if (m.text or "").startswith("/") or _has_bot_command(m):
        return
    if not state.diag_enabled:
        return
    uid = m.from_user.id if m.from_user else None
    uname = f"@{m.from_user.username}" if (m.from_user and m.from_user.username) else "-"
    is_bot = getattr(m.from_user, "is_bot", None) if m.from_user else None
    txt = (m.text or m.caption or "")
    has = _has_links_or_mentions(m)
    is_new = (uid is not None and is_newcomer(uid, m.chat.id))
    await log_bot_rights(m.chat.id)
    log.info("DIAG message: chat=%s mid=%s uid=%s %s is_bot=%s entities=[%s] has_links=%s newcomer=%s text=%r",
             m.chat.id, m.message_id, uid, uname, is_bot, _brief_entities(m), has, is_new, txt[:400])

@router.edited_message(group_msg_filter)
async def __diag_log_edit(m: 'Message'):
    if (m.text or "").startswith("/") or _has_bot_command(m):
        return
    if not state.diag_enabled:
        return
    uid = m.from_user.id if m.from_user else None
    uname = f"@{m.from_user.username}" if (m.from_user and m.from_user.username) else "-"
    is_bot = getattr(m.from_user, "is_bot", None) if m.from_user else None
    txt = (m.text or m.caption or "")
    has = _has_links_or_mentions(m)
    is_new = (uid is not None and is_newcomer(uid, m.chat.id))
    await log_bot_rights(m.chat.id)
    log.info("DIAG edited:  chat=%s mid=%s uid=%s %s is_bot=%s entities=[%s] has_links=%s newcomer=%s text=%r",
             m.chat.id, m.message_id, uid, uname, is_bot, _brief_entities(m), has, is_new, txt[:400])

# â”€â”€ Anti-link for newcomers (24h) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MENTION_OR_LINK_RE = re.compile(
    r'(?i)('
    r'https?://\S+|t\.me/\S+|www\.\S+|'
    r'@[A-Za-z0-9_]{4,}|'
    r'\b[A-Za-z0-9-]{2,}\.(?:com|ru|net|org|io|co|app|site|link|info|me|pro|dev)\b'
    r')'
)

@router.message(group_msg_filter)
async def newcomer_anti_links(m: 'Message'):
    await _antilink_core(m)

@router.edited_message(group_msg_filter)
async def newcomer_anti_links_edited(m: 'Message'):
    await _antilink_core(m)

# â”€â”€ Chat member updates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@router.chat_member()
async def on_chat_member_update(ev: 'ChatMemberUpdated'):
    if ev.chat.type not in {ChatType.GROUP, ChatType.SUPERGROUP}:
        return
    new_s = ev.new_chat_member.status
    old_s = ev.old_chat_member.status
    if new_s == ChatMemberStatus.MEMBER and old_s in {ChatMemberStatus.LEFT, ChatMemberStatus.KICKED, ChatMemberStatus.RESTRICTED}:
        u = ev.new_chat_member.user
        if u and not u.is_bot:
            record_approval(u.id, ev.chat.id)

# â”€â”€ TTL Expirer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def expire_old_requests() -> None:
    now = int(time.time())
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        rows = list(conn.execute("SELECT user_id, chat_id, chat_title, requested_at FROM pending_requests"))
        for user_id, chat_id, chat_title, requested_at in rows:
            if now - requested_at <= JOIN_REQUEST_TTL:
                continue
            try:
                log.info("TTL expired: approving & restricting user_id=%s chat_id=%s", user_id, chat_id)
                await bot.approve_chat_join_request(chat_id=chat_id, user_id=user_id)
                record_approval(user_id, chat_id)
                forever_days = 400
                await bot.restrict_chat_member(
                    chat_id=chat_id,
                    user_id=user_id,
                    permissions=_zero_perms(),
                    until_date=now + forever_days * 24 * 60 * 60,
                )
                title = chat_title or str(chat_id)
                open_url = await get_group_open_url(chat_id)
                if open_url:
                    title_html = f'<a href="{html.escape(open_url, quote=True)}">{html.escape(title)}</a>'
                else:
                    title_html = html.escape(title)
                admin_mention = await get_public_admin_mention(chat_id)
                if admin_mention:
                    txt = (
                        f"Ğ’Ñ‹ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ñ‹ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ {title_html}, Ğ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ° Ğ½Ğ°Ğ²ÑĞµĞ³Ğ´Ğ°.\n"
                        f"Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ°Ğ²Ğ¾ Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ, Ğ¿Ñ€Ğ¾Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ Ñƒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ° {admin_mention}."
                    )
                else:
                    txt = (
                        f"Ğ’Ñ‹ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ñ‹ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ {title_html}, Ğ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ° Ğ½Ğ°Ğ²ÑĞµĞ³Ğ´Ğ°.\n"
                        "Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ°Ğ²Ğ¾ Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ, Ğ¿Ñ€Ğ¾Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ Ñƒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°."
                    )
                try:
                    await bot.send_message(chat_id=user_id, text=txt, disable_web_page_preview=True)
                except Exception as e:
                    log.debug("DM to user %s failed: %s", user_id, e)
            except Exception:
                logging.exception("approve+restrict failed for user_id=%s chat_id=%s", user_id, chat_id)
            conn.execute("DELETE FROM pending_requests WHERE user_id=? AND chat_id=?", (user_id, chat_id))
        conn.commit()

async def expirer_loop():
    await asyncio.sleep(5)
    log.info("Expirer loop started: interval=%ss ttl=%ss", EXPIRE_SWEEP_INTERVAL, JOIN_REQUEST_TTL)
    while True:
        try:
            await expire_old_requests()
        except Exception:
            log.exception("expire_old_requests() crashed")
        await asyncio.sleep(EXPIRE_SWEEP_INTERVAL)

# â”€â”€ Optional systemd watchdog heartbeat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def watchdog_task():
    if SystemdNotifier is None:
        return
    try:
        n = SystemdNotifier()
        n.notify("READY=1")
        wd_usec = os.getenv("WATCHDOG_USEC")
        if not wd_usec:
            return
        interval = max(1.0, int(wd_usec) / 1_000_000 / 2.0)  # half of watchdog
        log.info("Systemd watchdog enabled: interval=%.1fs", interval)
        while True:
            n.notify("WATCHDOG=1")
            await asyncio.sleep(interval)
    except Exception as e:
        log.debug("Watchdog task stopped: %s", e)

# â”€â”€ Entry point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def main():
    init_db()
    # load toggles
    val = db_get_setting("sysclean_enabled")
    state.sys_clean_enabled = (val.lower() == "true") if val is not None else ENV_DELETE_SYSTEM_MESSAGES
    val2 = db_get_setting("botlock_enabled")
    state.botlock_enabled = (val2.lower() == "true") if val2 is not None else ENV_LOCKDOWN_NONADMIN_BOTS
    val3 = db_get_setting("diag_enabled")
    state.diag_enabled = (val3.lower() == "true") if val3 is not None else False

    me = await bot.get_me()
    state.me_id = me.id
    state.me_username = (me.username or "").lower()
    log.info("Bot username: @%s (support, sys-clean=%s, botlock=%s, diag=%s)",
             me.username, state.sys_clean_enabled, state.botlock_enabled, state.diag_enabled)
    log.info("ENV: SQLITE_PATH=%s DELETE_SYSTEM_MESSAGES=%s LOCKDOWN_NONADMIN_BOTS=%s AGGRESSIVE_CHANNEL_ANTILINK=%s ALLOWLIST=%s",
             SQLITE_PATH, ENV_DELETE_SYSTEM_MESSAGES, ENV_LOCKDOWN_NONADMIN_BOTS, AGGRESSIVE_CHANNEL_ANTILINK, sorted(ALLOWLIST) if ALLOWLIST else "ALL")

    # background tasks
    asyncio.create_task(expirer_loop())
    asyncio.create_task(watchdog_task())

    await dp.start_polling(
        bot,
        allowed_updates=["message", "edited_message", "chat_join_request", "callback_query", "chat_member"],
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        pass


# â”€â”€ Core anti-link (Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Ğ¸ Ğ´Ğ»Ñ Ñ€ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def _antilink_core(m: Message):
    if state.diag_enabled:
        has_l = _has_links_or_mentions(m)
        newc = (m.from_user and is_newcomer(m.from_user.id, m.chat.id)) if m.from_user else False
        log.info(
            "DIAG message: chat=%s mid=%s uid=%s is_bot=%s has_links=%s newcomer=%s text=%r",
            m.chat.id, m.message_id,
            getattr(getattr(m, "from_user", None), "id", None),
            getattr(getattr(m, "from_user", None), "is_bot", None),
            has_l, newc, (m.text or m.caption or "")[:180],
        )

    # ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ Ğ½Ğµ Ñ‚Ñ€Ğ¾Ğ³Ğ°ĞµĞ¼
    if m.text and m.text.startswith('/'):
        return

    # Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚ ĞºĞ°Ğ½Ğ°Ğ»Ğ°/Ğ°Ğ½Ğ¾Ğ½Ğ°
    if getattr(m, "sender_chat", None) is not None and getattr(m.sender_chat, "id", None) is not None:
        if AGGRESSIVE_CHANNEL_ANTILINK and _has_links_or_mentions(m):
            try:
                await bot.delete_message(m.chat.id, m.message_id)
                log.info("Aggressive AntiLink: deleted CHANNEL/ANON message mid=%s chat=%s", m.message_id, m.chat.id)
            except Exception as e:
                log.info("Aggressive AntiLink: failed mid=%s in chat %s: %s", m.message_id, m.chat.id, e)
        else:
            log.info("SKIP-AntiLink: sender_chat present but no links mid=%s chat=%s", m.message_id, m.chat.id)
        return

    if not m.from_user:
        log.info("SKIP-AntiLink: no from_user (channel/anon) mid=%s chat=%s", m.message_id, m.chat.id)
        return

    uid = m.from_user.id

    # ĞĞ´Ğ¼Ğ¸Ğ½Ğ°Ğ¼ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ²ÑÑ‘
    if await is_user_admin(uid, m.chat.id):
        log.info("SKIP-AntiLink: sender is admin uid=%s chat=%s mid=%s", uid, m.chat.id, m.message_id)
        return

    # ĞĞµÑ‚ ÑÑÑ‹Ğ»Ğ¾Ğº/ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ğ¹
    if not _has_links_or_mentions(m):
        if state.diag_enabled:
            log.info("SKIP-AntiLink: no link/mention uid=%s chat=%s mid=%s", uid, m.chat.id, m.message_id)
        return

    # ĞĞ±ĞµÑĞ¿ĞµÑ‡Ğ¸Ñ‚ÑŒ Ğ¾ĞºĞ½Ğ¾ Ğ½Ğ¾Ğ²Ğ¸Ñ‡ĞºĞ°
    nu = newcomer_until(uid, m.chat.id)
    if nu is None:
        record_approval(uid, m.chat.id)
        nu = newcomer_until(uid, m.chat.id)
    now = int(time.time())
    if not (nu and nu > now):
        log.info("SKIP-AntiLink: not newcomer uid=%s chat=%s mid=%s (until=%s now=%s)", uid, m.chat.id, m.message_id, nu, now)
        return

    try:
        await bot.delete_message(m.chat.id, m.message_id)
        log.info("AntiLink: deleted from user_id=%s chat_id=%s mid=%s", uid, m.chat.id, m.message_id)
    except Exception as e:
        log.info("AntiLink: failed delete mid=%s in chat %s: %s", m.message_id, m.chat.id, e)

# === NEWCOMER PROBE (debug-only, enable via NEWCOMER_PROBE=1 in /etc/tgbots/support.env) ===
try:
    if os.getenv("NEWCOMER_PROBE","0") == "1":
        log.info("PROBE: enabled")
        @router.message(~F.chat.type.in_({ChatType.PRIVATE}))
        async def __probe_newcomer_any_message(m: Message):
            u = m.from_user
            uid = getattr(u, "id", None)
            newcomer = (uid is not None and is_newcomer(uid, m.chat.id))
            log.info("PROBE: hit chat=%s type=%s mid=%s uid=%s newcomer=%s",
                     getattr(m.chat, "id", None), getattr(m.chat, "type", None),
                     getattr(m, "message_id", None), uid, newcomer)
            if newcomer and u and not u.is_bot:
                try:
                    await m.delete()
                    log.info("PROBE: deleted chat=%s mid=%s uid=%s", m.chat.id, m.message_id, uid)
                except Exception as e:
                    log.warning("PROBE: delete failed chat=%s mid=%s uid=%s err=%s", m.chat.id, getattr(m,'message_id',None), uid, e)
except Exception as _e:
    log.warning("PROBE: attach failed: %s", _e)
