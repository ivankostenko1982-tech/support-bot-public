#!/usr/bin/env python3
# app.py â€” "support" bot (aiogram v3)
#
# Features:
#   â€¢ Join-guard: DM button "Ğ¯ Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞº" with HMAC-signed short callback (anti-replay).
#     Format: v:<chat_id>:<ts>:<sig16> where sig16 = first 8 bytes of HMAC-SHA256 hex.
#   â€¢ Auto-approve on TTL expiry + permanent restrict (forever mute) + DM with clickable group title & admin mention.
#   â€¢ Newcomer anti-links for 24h after approval: deletes URLs, t.me, www.*, bare domains, and @mentions (admins excluded).
#     - Works for new messages and for edited messages.
#   â€¢ System service messages cleaner: /sysclean on|off (admin-only), persisted in SQLite; silent for non-admins.
#   â€¢ Allowlist by TARGET_CHAT_ID(S); admin-only commands /health, /allowlist, /sysclean.
#   â€¢ OPTIONAL: Lock down ANY non-admin bot forever (restrict all permissions), controlled by LOCKDOWN_NONADMIN_BOTS
#     and /botlock on|off (persisted).
#   â€¢ Records approval when: (a) user clicks button & we approve, (b) TTL auto-approve, (c) user joins via invite
#     (new_chat_members), (d) chat_member status turns to MEMBER. This ensures the 24h newcomer window refreshes on re-join.
#   â€¢ Link previews are disabled in all DMs with URLs.
#   â€¢ Diagnostics: /diag on|off (admin-only) â€” logs every group message/edit with entities, newcomer flag, and detector result.
#   â€¢ Aggressive channel anti-link (ENV AGGRESSIVE_CHANNEL_ANTILINK=true): deletes channel/anonymous posts with links even without from_user.
#
# ENV example (/etc/tgbots/support.env, each on its own line):
#   BOT_TOKEN=123456:ABC...
#   VERIFY_SECRET=superlongrandomsecret_please_change
#   TARGET_CHAT_IDS=-1002099408662,-1001878435829    # optional
#   JOIN_REQUEST_TTL=600                              # optional
#   DELETE_SYSTEM_MESSAGES=true                       # optional default for sysclean
#   EXPIRE_SWEEP_INTERVAL=20                          # optional
#   ADMIN_CONTACT_OVERRIDE=username                   # optional @username (public) for DM
#   ADMIN_IDS=123,456                                 # optional user_ids
#   SQLITE_PATH=/var/lib/tgbots/support.db           # optional
#   LOCKDOWN_NONADMIN_BOTS=true                       # optional default (can toggle by /botlock)
#   AGGRESSIVE_CHANNEL_ANTILINK=false                 # optional
#
from __future__ import annotations

import os, time, sqlite3, asyncio, logging, html, hmac, re
from dataclasses import dataclass
from contextlib import closing
from typing import Optional, List, Tuple, Set
from datetime import datetime, timedelta

from aiogram import Bot, Dispatcher, F, Router
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode, ChatType, ChatMemberStatus
from aiogram.filters import CommandStart, Command
from aiogram.types import (
    ChatJoinRequest, Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton,
    ChatMemberAdministrator, ChatMemberOwner, ChatMember, ChatPermissions, ChatMemberUpdated
)
from aiogram.utils.keyboard import InlineKeyboardBuilder

# â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(name)s | %(message)s")
log = logging.getLogger("support-join-guard")

# â”€â”€ ENV â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
BOT_TOKEN = (os.getenv("BOT_TOKEN") or "").strip()
VERIFY_SECRET = (os.getenv("VERIFY_SECRET") or "").strip()
if not BOT_TOKEN:
    raise SystemExit("BOT_TOKEN is required in /etc/tgbots/support.env")
if not VERIFY_SECRET:
    raise SystemExit("VERIFY_SECRET is required in /etc/tgbots/support.env")

JOIN_REQUEST_TTL = int(os.getenv("JOIN_REQUEST_TTL", "600"))
SQLITE_PATH = os.getenv("SQLITE_PATH", "./join_guard_state.db")
ENV_DELETE_SYSTEM_MESSAGES = os.getenv("DELETE_SYSTEM_MESSAGES", "false").lower() in {"1","true","yes","on"}
EXPIRE_SWEEP_INTERVAL = int(os.getenv("EXPIRE_SWEEP_INTERVAL", "20"))
ADMIN_CONTACT_OVERRIDE = (os.getenv("ADMIN_CONTACT_OVERRIDE") or "").strip().lstrip("@")
NEWCOMER_WINDOW_SECONDS = 24 * 60 * 60
ENV_LOCKDOWN_NONADMIN_BOTS = os.getenv("LOCKDOWN_NONADMIN_BOTS", "true").lower() in {"1","true","yes","on"}
AGGRESSIVE_CHANNEL_ANTILINK = os.getenv("AGGRESSIVE_CHANNEL_ANTILINK", "false").lower() in {"1","true","yes","on"}

def _parse_id_list(raw: str) -> Set[int]:
    ids: Set[int] = set()
    if not raw or not raw.strip():
        return ids
    parts = [p for chunk in raw.replace(",", " ").split() for p in [chunk]]
    for p in parts:
        if "=" in p:
            log.warning("Ignoring non-id token in list: %r", p)
            continue
        try:
            ids.add(int(p))
        except ValueError:
            log.warning("Skipping malformed ID: %r", p)
    return ids

ALLOWLIST = _parse_id_list(os.getenv("TARGET_CHAT_IDS", "")) | _parse_id_list(os.getenv("TARGET_CHAT_ID", ""))
if ALLOWLIST:
    log.info("Allowlist enabled for chat_ids=%s", sorted(ALLOWLIST))
else:
    log.info("Allowlist is empty â€” bot will accept join requests from ANY chat")

ADMIN_IDS = _parse_id_list(os.getenv("ADMIN_IDS", ""))
if ADMIN_IDS:
    log.info("Static admin ids set: %s", sorted(ADMIN_IDS))

# â”€â”€ Bot/Dispatcher/Router â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bot = Bot(token=BOT_TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()
router = Router()
dp.include_router(router)

# â”€â”€ App State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@dataclass
class AppState:
    sys_clean_enabled: bool = False
    me_id: Optional[int] = None
    botlock_enabled: bool = True
    diag_enabled: bool = False  # toggle via /diag

state = AppState()

# â”€â”€ SQLite â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
db_dir = os.path.dirname(SQLITE_PATH) or "."
os.makedirs(db_dir, exist_ok=True)

def init_db() -> None:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        cur = conn.cursor()
        cur.execute("PRAGMA journal_mode=WAL;")
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS pending_requests (
                user_id      INTEGER NOT NULL,
                chat_id      INTEGER NOT NULL,
                chat_title   TEXT,
                requested_at INTEGER NOT NULL,
                PRIMARY KEY (user_id, chat_id)
            )
            """
        )
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS settings (
                key   TEXT PRIMARY KEY,
                value TEXT NOT NULL
            )
            """
        )
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS approvals (
                user_id     INTEGER NOT NULL,
                chat_id     INTEGER NOT NULL,
                approved_at INTEGER NOT NULL,
                PRIMARY KEY (user_id, chat_id)
            )
            """
        )
        conn.commit()

def db_get_setting(key: str) -> Optional[str]:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        cur = conn.execute("SELECT value FROM settings WHERE key=?", (key,))
        row = cur.fetchone()
        return row[0] if row else None

def db_set_setting(key: str, value: str) -> None:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        conn.execute(
            "INSERT INTO settings(key,value) VALUES(?,?) "
            "ON CONFLICT(key) DO UPDATE SET value=excluded.value",
            (key, value),
        )
        conn.commit()

def set_pending(user_id: int, chat_id: int, chat_title: str) -> None:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        conn.execute(
            """
            INSERT INTO pending_requests(user_id, chat_id, chat_title, requested_at)
            VALUES (?, ?, ?, ?)
            ON CONFLICT(user_id, chat_id) DO UPDATE SET
                chat_title=excluded.chat_title,
                requested_at=excluded.requested_at
            """,
            (user_id, chat_id, chat_title, int(time.time())),
        )
        conn.commit()

def clear_pending(user_id: int, chat_id: int) -> None:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        conn.execute("DELETE FROM pending_requests WHERE user_id=? AND chat_id=?", (user_id, chat_id))
        conn.commit()

def record_approval(user_id: int, chat_id: int) -> None:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        conn.execute(
            """
            INSERT INTO approvals(user_id, chat_id, approved_at)
            VALUES (?, ?, ?)
            ON CONFLICT(user_id, chat_id) DO UPDATE SET
                approved_at=excluded.approved_at
            """,
            (user_id, chat_id, int(time.time())),
        )
        conn.commit()

def newcomer_until(user_id: int, chat_id: int) -> Optional[int]:
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        cur = conn.execute("SELECT approved_at FROM approvals WHERE user_id=? AND chat_id=?", (user_id, chat_id))
        row = cur.fetchone()
        if not row:
            return None
        return row[0] + NEWCOMER_WINDOW_SECONDS

def is_newcomer(user_id: int, chat_id: int) -> bool:
    until = newcomer_until(user_id, chat_id)
    return bool(until and until > int(time.time()))

# â”€â”€ Admin checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def is_user_admin(user_id: Optional[int], chat_id_context: Optional[int] = None) -> bool:
    if user_id is None:
        return False
    if user_id in ADMIN_IDS:
        return True
    if chat_id_context is not None:
        try:
            cm = await bot.get_chat_member(chat_id_context, user_id)
            if isinstance(cm, (ChatMemberAdministrator, ChatMemberOwner)):
                return True
        except Exception:
            pass
    if ALLOWLIST:
        for aid in ALLOWLIST:
            try:
                cm = await bot.get_chat_member(aid, user_id)
                if isinstance(cm, (ChatMemberAdministrator, ChatMemberOwner)):
                    return True
            except Exception:
                continue
    return not (ADMIN_IDS or ALLOWLIST)

async def ensure_admin(m: Message) -> bool:
    chat_id_ctx = m.chat.id if m.chat else None
    user_id = m.from_user.id if m.from_user else None
    sender_chat_id = m.sender_chat.id if m.sender_chat else None
    if sender_chat_id and chat_id_ctx and sender_chat_id == chat_id_ctx:
        return True
    return await is_user_admin(user_id, chat_id_ctx)

# â”€â”€ Signing helpers (short) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _sig16(payload: str) -> str:
    mac = hmac.new(VERIFY_SECRET.encode('utf-8'), payload.encode('utf-8'), digestmod='sha256').digest()
    return mac[:8].hex()  # 16 hex chars

def build_verify_cbdata(chat_id: int, user_id: int) -> str:
    ts = int(time.time())
    core = f"{chat_id}:{user_id}:{ts}"
    sig = _sig16(core)
    return f"v:{chat_id}:{ts}:{sig}"

def parse_and_verify_cbdata(cbdata: str, actual_user_id: int) -> tuple[bool, Optional[int], Optional[str]]:
    # v:<chat_id>:<ts>:<sig16>
    if not cbdata.startswith("v:"):
        return (False, None, "ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ")
    try:
        _, chat_id_s, ts_s, sig = cbdata.split(":", 3)
        chat_id = int(chat_id_s); ts = int(ts_s)
    except Exception:
        return (False, None, "ĞĞµĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ")
    if int(time.time()) - ts > JOIN_REQUEST_TTL + 30:
        return (False, None, "Ğ’Ñ€ĞµĞ¼Ñ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ Ğ¸ÑÑ‚ĞµĞºĞ»Ğ¾")
    core = f"{chat_id}:{actual_user_id}:{ts}"
    if _sig16(core) != sig:
        return (False, None, "ĞŸĞ¾Ğ´Ğ¿Ğ¸ÑÑŒ Ğ½Ğµ ÑÑ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ")
    return (True, chat_id, None)

# â”€â”€ UI helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def verify_keyboard(chat_id: int, user_id: int) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.button(text="âœ… Ğ¯ Ñ‡ĞµĞ»Ğ¾Ğ²ĞµĞº (Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ)", callback_data=build_verify_cbdata(chat_id, user_id))
    kb.button(text="ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="refresh")
    return kb.as_markup()

def requests_keyboard(user_id: int, requests: List[Tuple[int, str, int]]) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    for chat_id, chat_title, _ in requests:
        label = f"ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ğ² Â«{chat_title or chat_id}Â»"
        kb.button(text=label, callback_data=build_verify_cbdata(chat_id, user_id))
    kb.button(text="ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="refresh")
    return kb.as_markup()

async def get_public_admin_mention(chat_id: int) -> Optional[str]:
    if ADMIN_CONTACT_OVERRIDE:
        uname = ADMIN_CONTACT_OVERRIDE
        return f'<a href="https://t.me/{uname}">@{uname}</a>'
    try:
        admins: List[ChatMember] = await bot.get_chat_administrators(chat_id)
    except Exception as e:
        log.debug("get_chat_administrators failed for chat %s: %s", chat_id, e)
        return None
    for cm in admins:
        try:
            is_admin = isinstance(cm, (ChatMemberAdministrator, ChatMemberOwner))
            if not is_admin:
                continue
            if isinstance(cm, ChatMemberAdministrator) and getattr(cm, "is_anonymous", False):
                continue
            user = getattr(cm, "user", None)
            if not user or user.is_bot:
                continue
            uname = user.username
            if not uname:
                continue
            return f'<a href="https://t.me/{uname}">@{uname}</a>'
        except Exception:
            continue
    return None

async def get_group_open_url(chat_id: int) -> Optional[str]:
    try:
        chat = await bot.get_chat(chat_id)
        if getattr(chat, "username", None):
            return f"https://t.me/{chat.username}"
    except Exception as e:
        log.debug("get_chat failed for %s: %s", chat_id, e)
    try:
        expire = int((datetime.utcnow() + timedelta(minutes=30)).timestamp())
        link = await bot.create_chat_invite_link(
            chat_id=chat_id,
            name="auto-open",
            expire_date=expire,
            member_limit=1,
            creates_join_request=False,
        )
        return link.invite_link
    except Exception as e:
        log.debug("create_chat_invite_link failed for %s: %s", chat_id, e)
        return None

def open_group_keyboard(url: str, title: Optional[str] = None) -> InlineKeyboardMarkup:
    kb = InlineKeyboardBuilder()
    kb.add(InlineKeyboardButton(text=title or "ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ", url=url))
    return kb.as_markup()

# â”€â”€ Service messages cleaner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
service_filter = (
    (F.chat.type == ChatType.GROUP) | (F.chat.type == ChatType.SUPERGROUP)
) & (
    F.new_chat_members |
    F.left_chat_member |
    F.new_chat_title |
    F.new_chat_photo |
    F.delete_chat_photo |
    F.group_chat_created |
    F.supergroup_chat_created |
    F.migrate_to_chat_id |
    F.migrate_from_chat_id |
    F.pinned_message
)

@router.message(service_filter)
async def delete_service_messages(m: Message):
    if not state.sys_clean_enabled:
        return
    if ALLOWLIST and int(m.chat.id) not in ALLOWLIST:
        return
    try:
        await bot.delete_message(chat_id=m.chat.id, message_id=m.message_id)
    except Exception as e:
        logging.debug("delete_message failed in chat %s mid=%s: %s", m.chat.id, m.message_id, e)

# â”€â”€ Bot lockdown (optional) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _zero_perms() -> ChatPermissions:
    return ChatPermissions(
        can_send_messages=False,
        can_send_media_messages=False,
        can_send_polls=False,
        can_send_other_messages=False,
        can_add_web_page_previews=False,
        can_change_info=False,
        can_invite_users=False,
        can_pin_messages=False,
        can_manage_topics=False,
    )

async def _restrict_bot_forever(chat_id: int, user_id: int) -> None:
    if not state.botlock_enabled:
        return
    if state.me_id and user_id == state.me_id:
        return
    try:
        cm = await bot.get_chat_member(chat_id, user_id)
        if isinstance(cm, (ChatMemberAdministrator, ChatMemberOwner)):
            return  # Ğ½Ğµ Ñ‚Ñ€Ğ¾Ğ³Ğ°ĞµĞ¼ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ²/Ğ²Ğ»Ğ°Ğ´ĞµĞ»ÑŒÑ†ĞµĞ² (Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ Ğ±Ğ¾Ñ‚-Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ²)
    except Exception:
        pass
    try:
        now = int(time.time())
        forever_days = 400
        await bot.restrict_chat_member(
            chat_id=chat_id,
            user_id=user_id,
            permissions=_zero_perms(),
            until_date=now + forever_days * 24 * 60 * 60,
        )
        log.info("Bot lockdown: restricted bot user_id=%s in chat_id=%s", user_id, chat_id)
    except Exception as e:
        log.debug("Bot lockdown failed for user_id=%s chat_id=%s: %s", user_id, chat_id, e)

@router.message((F.chat.type.in_({ChatType.GROUP, ChatType.SUPERGROUP})) & F.new_chat_members)
async def on_new_members_lockdown(m: Message):
    # Lock non-admin bots; mark humans as approved (refresh newcomer window on re-join)
    for u in (m.new_chat_members or []):
        if u.is_bot:
            await _restrict_bot_forever(m.chat.id, u.id)
        else:
            record_approval(u.id, m.chat.id)

# If any bot posts something (edge cases) â€” lock it too
@router.message((F.chat.type.in_({ChatType.GROUP, ChatType.SUPERGROUP})) & F.from_user.as_("u"))
async def on_any_group_message_lock_bots(m: Message, u):
    try:
        if u and getattr(u, "is_bot", False):
            await _restrict_bot_forever(m.chat.id, u.id)
    except Exception:
        pass

# â”€â”€ Join Request flow â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@router.chat_join_request()
async def on_join_request(event: ChatJoinRequest):
    if ALLOWLIST and int(event.chat.id) not in ALLOWLIST:
        log.info("Ignoring join request for non-allowed chat_id=%s title=%s", event.chat.id, event.chat.title)
        return

    set_pending(event.from_user.id, event.chat.id, event.chat.title or "")

    title = event.chat.title or "Ğ³Ñ€ÑƒĞ¿Ğ¿Ğ°"
    open_url = await get_group_open_url(event.chat.id)
    if open_url:
        title_html = f'<a href="{html.escape(open_url, quote=True)}">{html.escape(title)}</a>'
    else:
        title_html = html.escape(title)

    text = (
        f"ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ²ÑÑ‚ÑƒĞ¿Ğ¸Ñ‚ÑŒ Ğ² {title_html}, Ğ¿Ñ€Ğ¾Ğ¹Ğ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ñ€Ğ¾Ñ‚ĞºÑƒÑ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ.\n\n"
        "ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ â€” Ğ¸ Ğ²Ñ‹ Ğ±ÑƒĞ´ĞµÑ‚Ğµ Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ñ‹ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸. "
        "Ğ•ÑĞ»Ğ¸ ĞºĞ½Ğ¾Ğ¿ĞºĞ° Ğ½Ğµ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚, Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ /start ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·."
    )

    try:
        await bot.send_message(
            chat_id=event.from_user.id,
            text=text,
            reply_markup=verify_keyboard(chat_id=event.chat.id, user_id=event.from_user.id),
            disable_web_page_preview=True,
        )
    except Exception as e:
        log.info("DM failed (maybe user hasn't started bot yet): %s", e)

# â”€â”€ Start & callbacks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@router.message(CommandStart())
async def on_start(message: Message):
    await expire_old_requests()
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        rows = list(conn.execute(
            "SELECT chat_id, chat_title, requested_at FROM pending_requests WHERE user_id=?",
            (message.from_user.id,)
        ))
    if not rows:
        kb = InlineKeyboardBuilder()
        kb.button(text="ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ", callback_data="refresh")
        await message.answer(
            "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚! ĞŸĞ¾ĞºĞ° Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ·Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğ° Ğ²ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ.\n"
            "Ğ•ÑĞ»Ğ¸ Ğ²Ñ‹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‡Ñ‚Ğ¾ Ğ½Ğ°Ğ¶Ğ°Ğ»Ğ¸ Â«Ğ’ÑÑ‚ÑƒĞ¿Ğ¸Ñ‚ÑŒÂ», Ğ¿Ğ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸Ñ‚Ğµ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ ÑĞµĞºÑƒĞ½Ğ´ Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Â«ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒÂ».",
            reply_markup=kb.as_markup(),
        )
        return

    if len(rows) == 1:
        chat_id, chat_title, _ = rows[0]
        await message.answer(
            f"Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ²ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ğ² Â«{html.escape(chat_title) if chat_title else chat_id}Â». ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ.",
            reply_markup=verify_keyboard(chat_id=chat_id, user_id=message.from_user.id),
        )
    else:
        await message.answer(
            "ĞĞ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‡Ğ°Ñ‚ Ğ½Ğ¸Ğ¶Ğµ:",
            reply_markup=requests_keyboard(message.from_user.id, rows),
        )

@router.callback_query(F.data == "refresh")
async def on_refresh(cb: CallbackQuery):
    await expire_old_requests()
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        rows = list(conn.execute(
            "SELECT chat_id, chat_title, requested_at FROM pending_requests WHERE user_id=?",
            (cb.from_user.id,)
        ))
    if not rows:
        try:
            await cb.message.edit_text("Ğ—Ğ°ÑĞ²Ğ¾Ğº Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾. Ğ•ÑĞ»Ğ¸ Ğ²Ñ‹ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‡Ñ‚Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ, Ğ¿Ğ¾Ğ´Ğ¾Ğ¶Ğ´Ğ¸Ñ‚Ğµ Ğ¸ Ğ½Ğ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ·.")
        except Exception:
            pass
        await cb.answer("ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾")
        return

    if len(rows) == 1:
        chat_id, chat_title, _ = rows[0]
        await cb.message.edit_text(
            f"Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğ° Ğ²ÑÑ‚ÑƒĞ¿Ğ»ĞµĞ½Ğ¸Ğµ Ğ² Â«{html.escape(chat_title) if chat_title else chat_id}Â». ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¸Ñ.",
            reply_markup=verify_keyboard(chat_id=chat_id, user_id=cb.from_user.id),
        )
        await cb.answer("ĞĞº")
        return

    await cb.message.edit_text(
        "ĞĞ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ½ĞµÑĞºĞ¾Ğ»ÑŒĞºĞ¾ Ğ·Ğ°ÑĞ²Ğ¾Ğº. Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‡Ğ°Ñ‚ Ğ½Ğ¸Ğ¶Ğµ:",
        reply_markup=requests_keyboard(cb.from_user.id, rows),
    )
    await cb.answer("ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¾")

@router.callback_query(F.data.startswith("v:"))
async def on_verify(cb: CallbackQuery):
    ok, chat_id, err = parse_and_verify_cbdata(cb.data, actual_user_id=cb.from_user.id)
    if not ok or chat_id is None:
        await cb.answer(err or "ĞÑˆĞ¸Ğ±ĞºĞ°", show_alert=True)
        return

    if ALLOWLIST and chat_id not in ALLOWLIST:
        await cb.answer("Ğ­Ñ‚Ğ° Ğ·Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ¸Ğ· Ñ€Ğ°Ğ·Ñ€ĞµÑˆÑ‘Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ñ‡Ğ°Ñ‚Ğ°.", show_alert=True)
        return

    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        row = conn.execute(
            "SELECT chat_title, requested_at FROM pending_requests WHERE user_id=? AND chat_id=?",
            (cb.from_user.id, chat_id),
        ).fetchone()

    if not row:
        await cb.answer("Ğ—Ğ°ÑĞ²ĞºĞ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ° Ğ¸Ğ»Ğ¸ ÑƒÑÑ‚Ğ°Ñ€ĞµĞ»Ğ°. ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Â«ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒÂ».", show_alert=True)
        return

    chat_title, requested_at = row
    chat_title_safe = html.escape(chat_title) if chat_title else str(chat_id)

    if int(time.time()) - int(requested_at) > JOIN_REQUEST_TTL:
        clear_pending(cb.from_user.id, chat_id)
        try:
            await bot.decline_chat_join_request(chat_id=chat_id, user_id=cb.from_user.id)
        except Exception:
            pass
        await cb.answer("Ğ—Ğ°ÑĞ²ĞºĞ° Ğ¿Ñ€Ğ¾ÑÑ€Ğ¾Ñ‡ĞµĞ½Ğ°. ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ĞµÑ‘ Ğ·Ğ°Ğ½Ğ¾Ğ²Ğ¾.", show_alert=True)
        return

    try:
        await bot.approve_chat_join_request(chat_id=chat_id, user_id=cb.from_user.id)
        record_approval(cb.from_user.id, chat_id)
        clear_pending(cb.from_user.id, chat_id)

        await cb.message.edit_text(
            f"Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! Ğ—Ğ°ÑĞ²ĞºĞ° Ğ¾Ğ´Ğ¾Ğ±Ñ€ĞµĞ½Ğ° â€” Ğ´Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² Â«{chat_title_safe}Â».",
        )
        await cb.answer("ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´ĞµĞ½Ğ¾ âœ…")

        url = await get_group_open_url(chat_id)
        if url:
            try:
                await bot.send_message(
                    chat_id=cb.from_user.id,
                    text=f"Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ! ĞÑ‚ĞºÑ€Ğ¾Ğ¹Ñ‚Ğµ Ñ‡Ğ°Ñ‚ Â«{chat_title_safe}Â»:",
                    reply_markup=open_group_keyboard(url, title=f"ĞŸĞµÑ€ĞµĞ¹Ñ‚Ğ¸ Ğ² Â«{chat_title_safe}Â»"),
                    disable_web_page_preview=True,
                )
            except Exception as e:
                log.debug("DM with open button failed: %s", e)

    except Exception as e:
        log.exception("approve_chat_join_request failed")
        await cb.answer("ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ğ´Ğ¾Ğ±Ñ€Ğ¸Ñ‚ÑŒ. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ¿Ğ¾Ğ·Ğ¶Ğµ.", show_alert=True)

# â”€â”€ Admin commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@router.message(Command("health"))
async def health(m: Message):
    if not await ensure_admin(m): return
    await m.answer("ok")

@router.message(Command("allowlist"))
async def allowlist_cmd(m: Message):
    if not await ensure_admin(m): return
    if ALLOWLIST:
        await m.answer("Ğ Ğ°Ğ·Ñ€ĞµÑˆÑ‘Ğ½Ğ½Ñ‹Ğµ chat_id:\n" + "\n".join(str(i) for i in sorted(ALLOWLIST)))
    else:
        await m.answer("Ğ Ğ°Ğ·Ñ€ĞµÑˆÑ‘Ğ½Ğ½Ñ‹Ğµ chat_id Ğ½Ğµ Ğ·Ğ°Ğ´Ğ°Ğ½Ñ‹ (Ğ±Ğ¾Ñ‚ Ğ¿Ñ€Ğ¸Ğ½Ğ¸Ğ¼Ğ°ĞµÑ‚ Ğ·Ğ°ÑĞ²ĞºĞ¸ Ğ¸Ğ· Ğ»ÑĞ±Ñ‹Ñ… Ñ‡Ğ°Ñ‚Ğ¾Ğ²).")

@router.message(Command("sysclean"))
async def sysclean_cmd(m: Message):
    if not await ensure_admin(m): return
    parts = (m.text or "").split()
    if len(parts) == 1:
        origin = "override(Ğ‘Ğ”)" if db_get_setting("sysclean_enabled") is not None else "env"
        await m.answer(
            f"ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ ÑĞµĞ¹Ñ‡Ğ°Ñ {'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if state.sys_clean_enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'} "
            f"(Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº: {origin}).\n"
            f"Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: /sysclean on  Ğ¸Ğ»Ğ¸  /sysclean off"
        )
        return
    arg = parts[1].strip().lower()
    if arg in {"on", "off"}:
        enabled = (arg == "on")
        db_set_setting("sysclean_enabled", "true" if enabled else "false")
        state.sys_clean_enabled = enabled
        await m.answer(
            f"Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾. ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ñ‚ĞµĞ¿ĞµÑ€ÑŒ "
            f"{'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'} (ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾, Ğ¿ĞµÑ€ĞµĞ¶Ğ¸Ğ²Ñ‘Ñ‚ Ñ€ĞµÑÑ‚Ğ°Ñ€Ñ‚)."
        )
    else:
        await m.answer("ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: /sysclean on  Ğ¸Ğ»Ğ¸  /sysclean off")

@router.message(Command("botlock"))
async def botlock_cmd(m: Message):
    if not await ensure_admin(m): return
    parts = (m.text or "").split()
    if len(parts) == 1:
        origin = "override(Ğ‘Ğ”)" if db_get_setting("botlock_enabled") is not None else "env"
        await m.answer(
            f"Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ½Ğµ-Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ±Ğ¾Ñ‚Ğ¾Ğ² ÑĞµĞ¹Ñ‡Ğ°Ñ {'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if state.botlock_enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'} "
            f"(Ğ¸ÑÑ‚Ğ¾Ñ‡Ğ½Ğ¸Ğº: {origin}).\n"
            f"Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: /botlock on  Ğ¸Ğ»Ğ¸  /botlock off"
        )
        return
    arg = parts[1].strip().lower()
    if arg in {"on", "off"}:
        enabled = (arg == "on")
        db_set_setting("botlock_enabled", "true" if enabled else "false")
        state.botlock_enabled = enabled
        await m.answer(
            f"Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾. Ğ‘Ğ»Ğ¾ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ° Ğ½Ğµ-Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ±Ğ¾Ñ‚Ğ¾Ğ² Ñ‚ĞµĞ¿ĞµÑ€ÑŒ "
            f"{'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'} (ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾, Ğ¿ĞµÑ€ĞµĞ¶Ğ¸Ğ²Ñ‘Ñ‚ Ñ€ĞµÑÑ‚Ğ°Ñ€Ñ‚)."
        )
    else:
        await m.answer("ĞĞµĞ²ĞµÑ€Ğ½Ñ‹Ğ¹ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: /botlock on  Ğ¸Ğ»Ğ¸  /botlock off")

# â”€â”€ Diagnostics toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@router.message(Command("diag"))
async def diag_cmd(m: Message):
    if not await ensure_admin(m):  # Ğ¼Ğ¾Ğ»Ñ‡Ğ¸Ğ¼ Ğ´Ğ»Ñ Ğ½Ğµ-Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ²
        return
    parts = (m.text or "").split()
    if len(parts) == 1:
        await m.answer(f"Ğ”Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ° Ğ»Ğ¾Ğ³Ğ¾Ğ² ÑĞµĞ¹Ñ‡Ğ°Ñ {'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if state.diag_enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'}.\nĞ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹: /diag on | /diag off")
        return
    arg = parts[1].strip().lower()
    if arg in {"on", "off"}:
        enabled = (arg == "on")
        db_set_setting("diag_enabled", "true" if enabled else "false")
        state.diag_enabled = enabled
        await m.answer(f"Ğ”Ğ¸Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ° Ğ»Ğ¾Ğ³Ğ¾Ğ² {'Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°' if enabled else 'Ğ²Ñ‹ĞºĞ»ÑÑ‡ĞµĞ½Ğ°'} (ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾).")

# â”€â”€ DIAG handlers (must be above anti-link for clearer logs) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
group_msg_filter = (F.chat.type == ChatType.SUPERGROUP) | (F.chat.type == ChatType.GROUP)

def _brief_entities(m: Message):
    ents = []
    for e in (m.entities or []) + (m.caption_entities or []):
        ents.append(getattr(e, "type", "?"))
    return ",".join(ents) if ents else "-"

def _has_links_or_mentions(m: Message) -> bool:
    txt = (m.text or m.caption or "")
    if MENTION_OR_LINK_RE.search(txt):
        return True
    for ent in (m.entities or []) + (m.caption_entities or []):
        if getattr(ent, "type", None) in ("url", "text_link", "mention"):
            return True
    return False

@router.message(group_msg_filter)
async def __diag_log_new(m: Message):
    if not state.diag_enabled:
        return
    uid = m.from_user.id if m.from_user else None
    uname = f"@{m.from_user.username}" if (m.from_user and m.from_user.username) else "-"
    is_bot = getattr(m.from_user, "is_bot", None) if m.from_user else None
    txt = (m.text or m.caption or "")
    has = _has_links_or_mentions(m)
    is_new = (uid is not None and is_newcomer(uid, m.chat.id))
    log.info("DIAG message: chat=%s mid=%s uid=%s %s is_bot=%s entities=[%s] has_links=%s newcomer=%s text=%r",
             m.chat.id, m.message_id, uid, uname, is_bot, _brief_entities(m), has, is_new, txt[:400])

@router.edited_message(group_msg_filter)
async def __diag_log_edit(m: Message):
    if not state.diag_enabled:
        return
    uid = m.from_user.id if m.from_user else None
    uname = f"@{m.from_user.username}" if (m.from_user and m.from_user.username) else "-"
    is_bot = getattr(m.from_user, "is_bot", None) if m.from_user else None
    txt = (m.text or m.caption or "")
    has = _has_links_or_mentions(m)
    is_new = (uid is not None and is_newcomer(uid, m.chat.id))
    log.info("DIAG edited:  chat=%s mid=%s uid=%s %s is_bot=%s entities=[%s] has_links=%s newcomer=%s text=%r",
             m.chat.id, m.message_id, uid, uname, is_bot, _brief_entities(m), has, is_new, txt[:400])

# â”€â”€ Anti-link for newcomers (24h) â€” including @mentions & bare domains â”€â”€â”€â”€â”€â”€â”€â”€â”€
MENTION_OR_LINK_RE = re.compile(
    r'(?i)('
    r'https?://\S+|t\.me/\S+|www\.\S+|'                                # ÑĞ²Ğ½Ñ‹Ğµ ÑÑÑ‹Ğ»ĞºĞ¸
    r'@[A-Za-z0-9_]{4,}|'                                              # ÑƒĞ¿Ğ¾Ğ¼Ğ¸Ğ½Ğ°Ğ½Ğ¸Ñ
    r'\b[A-Za-z0-9-]{2,}\.(?:com|ru|net|org|io|co|app|site|link|info|me|pro|dev)\b'  # Ğ³Ğ¾Ğ»Ñ‹Ğµ Ğ´Ğ¾Ğ¼ĞµĞ½Ñ‹
    r')'
)

@router.message(group_msg_filter)
async def newcomer_anti_links(m: Message):
    # Posts from channels/anonymous admins have no from_user
    if not m.from_user:
        if AGGRESSIVE_CHANNEL_ANTILINK and _has_links_or_mentions(m):
            try:
                await bot.delete_message(m.chat.id, m.message_id)
                log.info("Aggressive AntiLink: deleted CHANNEL/ANON message mid=%s chat=%s", m.message_id, m.chat.id)
            except Exception as e:
                log.info("Aggressive AntiLink: failed mid=%s in chat %s: %s", m.message_id, m.chat.id, e)
        else:
            log.info("SKIP-AntiLink: no from_user (channel/anon) mid=%s chat=%s", m.message_id, m.chat.id)
        return

    # Skip admins
    if await is_user_admin(m.from_user.id, m.chat.id):
        log.info("SKIP-AntiLink: sender is admin uid=%s chat=%s mid=%s", m.from_user.id, m.chat.id, m.message_id)
        return

    uid = m.from_user.id
    # If we don't have an approval record (join via invite, manual approve) â€” create one now
    if newcomer_until(uid, m.chat.id) is None:
        record_approval(uid, m.chat.id)

    if not is_newcomer(uid, m.chat.id):
        log.info("SKIP-AntiLink: not newcomer uid=%s chat=%s mid=%s", uid, m.chat.id, m.message_id)
        return

    if not _has_links_or_mentions(m):
        log.info("SKIP-AntiLink: no link/mention uid=%s chat=%s mid=%s", uid, m.chat.id, m.message_id)
        return

    try:
        await bot.delete_message(m.chat.id, m.message_id)
        log.info("AntiLink: deleted from user_id=%s chat_id=%s mid=%s", uid, m.chat.id, m.message_id)
    except Exception as e:
        log.info("AntiLink: failed delete mid=%s in chat %s: %s", m.message_id, m.chat.id, e)

# Edited messages too
@router.edited_message(group_msg_filter)
async def newcomer_anti_links_edited(m: Message):
    if not m.from_user:
        if AGGRESSIVE_CHANNEL_ANTILINK and _has_links_or_mentions(m):
            try:
                await bot.delete_message(m.chat.id, m.message_id)
                log.info("Aggressive AntiLink(EDIT): deleted CHANNEL/ANON mid=%s chat=%s", m.message_id, m.chat.id)
            except Exception as e:
                log.info("Aggressive AntiLink(EDIT): failed mid=%s in chat %s: %s", m.message_id, m.chat.id, e)
        else:
            log.info("SKIP-AntiLink(EDIT): no from_user (channel/anon) mid=%s chat=%s", m.message_id, m.chat.id)
        return

    if await is_user_admin(m.from_user.id, m.chat.id):
        log.info("SKIP-AntiLink(EDIT): sender is admin uid=%s chat=%s mid=%s", m.from_user.id, m.chat.id, m.message_id)
        return

    uid = m.from_user.id
    if newcomer_until(uid, m.chat.id) is None:
        record_approval(uid, m.chat.id)

    if not is_newcomer(uid, m.chat.id):
        log.info("SKIP-AntiLink(EDIT): not newcomer uid=%s chat=%s mid=%s", uid, m.chat.id, m.message_id)
        return

    if not _has_links_or_mentions(m):
        log.info("SKIP-AntiLink(EDIT): no link/mention uid=%s chat=%s mid=%s", uid, m.chat.id, m.message_id)
        return

    try:
        await bot.delete_message(m.chat.id, m.message_id)
        log.info("AntiLink(EDIT): deleted from user_id=%s chat_id=%s mid=%s", uid, m.chat.id, m.message_id)
    except Exception as e:
        log.info("AntiLink(EDIT): failed delete mid=%s in chat %s: %s", m.message_id, m.chat.id, e)

# â”€â”€ Chat member status updates â†’ refresh newcomer window on rejoin â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@router.chat_member()
async def on_chat_member_update(ev: ChatMemberUpdated):
    if ev.chat.type not in {ChatType.GROUP, ChatType.SUPERGROUP}:
        return
    new_s = ev.new_chat_member.status
    old_s = ev.old_chat_member.status
    # Became member from left/kicked/restricted â†’ treat as (re)approval
    if new_s == ChatMemberStatus.MEMBER and old_s in {ChatMemberStatus.LEFT, ChatMemberStatus.KICKED, ChatMemberStatus.RESTRICTED}:
        u = ev.new_chat_member.user
        if u and not u.is_bot:
            record_approval(u.id, ev.chat.id)

# â”€â”€ TTL Expirer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def expire_old_requests() -> None:
    now = int(time.time())
    with closing(sqlite3.connect(SQLITE_PATH)) as conn:
        rows = list(conn.execute("SELECT user_id, chat_id, chat_title, requested_at FROM pending_requests"))
        for user_id, chat_id, chat_title, requested_at in rows:
            if now - requested_at <= JOIN_REQUEST_TTL:
                continue
            try:
                log.info("TTL expired: approving & restricting user_id=%s chat_id=%s", user_id, chat_id)
                await bot.approve_chat_join_request(chat_id=chat_id, user_id=user_id)
                record_approval(user_id, chat_id)  # mark/refresh newcomer window
                forever_days = 400
                await bot.restrict_chat_member(
                    chat_id=chat_id,
                    user_id=user_id,
                    permissions=_zero_perms(),
                    until_date=now + forever_days * 24 * 60 * 60,
                )
                title = chat_title or str(chat_id)
                open_url = await get_group_open_url(chat_id)
                if open_url:
                    title_html = f'<a href="{html.escape(open_url, quote=True)}">{html.escape(title)}</a>'
                else:
                    title_html = html.escape(title)
                admin_mention = await get_public_admin_mention(chat_id)
                if admin_mention:
                    txt = (
                        f"Ğ’Ñ‹ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ñ‹ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ {title_html}, Ğ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ° Ğ½Ğ°Ğ²ÑĞµĞ³Ğ´Ğ°.\n"
                        f"Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ°Ğ²Ğ¾ Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ, Ğ¿Ñ€Ğ¾Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ Ñƒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ° {admin_mention}."
                    )
                else:
                    txt = (
                        f"Ğ’Ñ‹ Ğ¿Ñ€Ğ¸Ğ½ÑÑ‚Ñ‹ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ {title_html}, Ğ½Ğ¾ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ° Ğ½Ğ°Ğ²ÑĞµĞ³Ğ´Ğ°.\n"
                        "Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ°Ğ²Ğ¾ Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ, Ğ¿Ñ€Ğ¾Ğ¹Ğ´Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºÑƒ Ñƒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ°."
                    )
                try:
                    await bot.send_message(chat_id=user_id, text=txt, disable_web_page_preview=True)
                except Exception as e:
                    log.debug("DM to user %s failed: %s", user_id, e)
            except Exception:
                logging.exception("approve+restrict failed for user_id=%s chat_id=%s", user_id, chat_id)
            conn.execute("DELETE FROM pending_requests WHERE user_id=? AND chat_id=?", (user_id, chat_id))
        conn.commit()

async def expirer_loop():
    await asyncio.sleep(5)
    log.info("Expirer loop started: interval=%ss ttl=%ss", EXPIRE_SWEEP_INTERVAL, JOIN_REQUEST_TTL)
    while True:
        try:
            await expire_old_requests()
        except Exception:
            log.exception("expire_old_requests() crashed")
        await asyncio.sleep(EXPIRE_SWEEP_INTERVAL)

# â”€â”€ Entry point â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def main():
    init_db()
    # load toggles
    val = db_get_setting("sysclean_enabled")
    state.sys_clean_enabled = (val.lower() == "true") if val is not None else ENV_DELETE_SYSTEM_MESSAGES
    val2 = db_get_setting("botlock_enabled")
    state.botlock_enabled = (val2.lower() == "true") if val2 is not None else ENV_LOCKDOWN_NONADMIN_BOTS
    val3 = db_get_setting("diag_enabled")
    state.diag_enabled = (val3.lower() == "true") if val3 is not None else False

    me = await bot.get_me()
    state.me_id = me.id
    log.info("Bot username: @%s (support, sys-clean=%s, botlock=%s, diag=%s)",
             me.username, state.sys_clean_enabled, state.botlock_enabled, state.diag_enabled)

    asyncio.create_task(expirer_loop())
    await dp.start_polling(
        bot,
        allowed_updates=["message", "edited_message", "chat_join_request", "callback_query", "chat_member"],
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        pass
