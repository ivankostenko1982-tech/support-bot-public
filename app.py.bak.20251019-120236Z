from __future__ import annotations

try:
    import _watchdog_testuser as _wd
    HAS_WD = True
except Exception as _e:
    HAS_WD = False
#!/usr/bin/env python3


# --- safe stub: replaced with test-only newcomer logic ---
def _removed_is_newcomer(uid: int, chat_id: int) -> bool:
    """Return True only for TEST_USER_ID in TEST_CHAT_ID while NEWCOMER_TEST_ONLY=1.
    Reads newcomer_until from approvals; safe-fails to False.
    """
    try:
        import os, time, sqlite3
        from contextlib import closing

        if os.getenv("NEWCOMER_TEST_ONLY","0") != "1":
            return False

        tc = int(os.getenv("TEST_CHAT_ID","0") or 0)
        tu = int(os.getenv("TEST_USER_ID","0") or 0)
        if not (tc and tu):
            return False
        if int(chat_id) != tc or int(uid) != tu:
            return False

        dbp = os.getenv("SQLITE_PATH","/opt/tgbots/bots/support/join_guard_state.db")
        with closing(sqlite3.connect(dbp, timeout=3.0)) as conn:
            row = conn.execute(
                "SELECT newcomer_until FROM approvals WHERE user_id=? AND chat_id=?",
                (int(uid), int(chat_id))
            ).fetchone()
            if not row:
                return False
            nu = int(row[0] or 0)
            return nu > int(time.time())
    except Exception:
        return False

@router.message(group_msg_filter)
async def __diag_log_new(m: 'Message'):
    # Команды не трогаем
    if (m.text or "").startswith("/") or _has_bot_command(m):
        return
    if not state.diag_enabled:
        return
    uid = m.from_user.id if m.from_user else None
    uname = f"@{m.from_user.username}" if (m.from_user and m.from_user.username) else "-"
    is_bot = getattr(m.from_user, "is_bot", None) if m.from_user else None
    txt = (m.text or m.caption or "")
    has = _has_links_or_mentions(m)
    is_new = (uid is not None and _removed_is_newcomer(uid, m.chat.id))
    await log_bot_rights(m.chat.id)
    log.info("DIAG message: chat=%s mid=%s uid=%s %s is_bot=%s entities=[%s] has_links=%s newcomer=%s text=%r",
             m.chat.id, m.message_id, uid, uname, is_bot, _brief_entities(m), has, is_new, txt[:400])

@router.edited_message(group_msg_filter)
async def __diag_log_edit(m: 'Message'):
    if (m.text or "").startswith("/") or _has_bot_command(m):
        return
    if not state.diag_enabled:
        return
    uid = m.from_user.id if m.from_user else None
    uname = f"@{m.from_user.username}" if (m.from_user and m.from_user.username) else "-"
    is_bot = getattr(m.from_user, "is_bot", None) if m.from_user else None
    txt = (m.text or m.caption or "")
    has = _has_links_or_mentions(m)
    is_new = (uid is not None and _removed_is_newcomer(uid, m.chat.id))
    await log_bot_rights(m.chat.id)
    log.info("DIAG edited:  chat=%s mid=%s uid=%s %s is_bot=%s entities=[%s] has_links=%s newcomer=%s text=%r",
             m.chat.id, m.message_id, uid, uname, is_bot, _brief_entities(m), has, is_new, txt[:400])

# ── Anti-link for newcomers (24h) ──────────────────────────────────────────────
MENTION_OR_LINK_RE = re.compile(
    r'(?i)('
    r'https?://\S+|t\.me/\S+|www\.\S+|'
    r'@[A-Za-z0-9_]{4,}|'
    r'\b[A-Za-z0-9-]{2,}\.(?:com|ru|net|org|io|co|app|site|link|info|me|pro|dev)\b'
    r')'
)

@router.message(group_msg_filter)
async def newcomer_anti_links(m: 'Message'):
    await _antilink_core(m)

@router.edited_message(group_msg_filter)
async def newcomer_anti_links_edited(m: 'Message'):
    await _antilink_core(m)

# ── Chat member updates ─────────────────────────────────────────────────────────
@router.chat_member()
async def on_chat_member_update(ev: 'ChatMemberUpdated'):
    if ev.chat.type not in {ChatType.GROUP, ChatType.SUPERGROUP}:
        return
    new_s = ev.new_chat_member.status
    old_s = ev.old_chat_member.status
    if new_s == ChatMemberStatus.MEMBER and old_s in {ChatMemberStatus.LEFT, ChatMemberStatus.KICKED, ChatMemberStatus.RESTRICTED}:
        u = ev.new_chat_member.user
        if u and not u.is_bot:
            pass
            
# ── TTL Expirer ────────────────────────────────────────────────────────────────
async def expire_old_requests() -> None:
    now = int(time.time())
    with closing(sqlite3.connect(SQLITE_PATH, timeout=3.0)) as conn:
        rows = list(conn.execute("SELECT user_id, chat_id, chat_title, requested_at FROM pending_requests"))
        for user_id, chat_id, chat_title, requested_at in rows:
            if now - requested_at <= JOIN_REQUEST_TTL:
                continue
            try:
                log.info("TTL expired: approving & restricting user_id=%s chat_id=%s", user_id, chat_id)
                await bot.approve_chat_join_request(chat_id=chat_id, user_id=user_id)
                record_approval(user_id, chat_id)
                forever_days = 400
                await bot.restrict_chat_member(
                    chat_id=chat_id,
                    user_id=user_id,
                    permissions=_zero_perms(),
                    until_date=now + forever_days * 24 * 60 * 60,
                )
                title = chat_title or str(chat_id)
                open_url = await get_group_open_url(chat_id)
                if open_url:
                    title_html = f'<a href="{html.escape(open_url, quote=True)}">{html.escape(title)}</a>'
                else:
                    title_html = html.escape(title)
                admin_mention = await get_public_admin_mention(chat_id)
                if admin_mention:
                    txt = (
                        f"Вы приняты в группу {title_html}, но отправка сообщений отключена навсегда.\n"
                        f"Чтобы получить право писать, пройдите проверку у администратора {admin_mention}."
                    )
                else:
                    txt = (
                        f"Вы приняты в группу {title_html}, но отправка сообщений отключена навсегда.\n"
                        "Чтобы получить право писать, пройдите проверку у администратора."
                    )
                try:
                    await bot.send_message(chat_id=user_id, text=txt, disable_web_page_preview=True)
                except Exception as e:
                    log.debug("DM to user %s failed: %s", user_id, e)
            except Exception:
                logging.exception("approve+restrict failed for user_id=%s chat_id=%s", user_id, chat_id)
            conn.execute("DELETE FROM pending_requests WHERE user_id=? AND chat_id=?", (user_id, chat_id))
        conn.commit()

async def expirer_loop():
    await asyncio.sleep(5)
    log.info("Expirer loop started: interval=%ss ttl=%ss", EXPIRE_SWEEP_INTERVAL, JOIN_REQUEST_TTL)
    while True:
        try:
            await expire_old_requests()
        except Exception:
            log.exception("expire_old_requests() crashed")
        await asyncio.sleep(EXPIRE_SWEEP_INTERVAL)

# ── Optional systemd watchdog heartbeat ────────────────────────────────────────
async def watchdog_task():
    if SystemdNotifier is None:
        return
    try:
        n = SystemdNotifier()
        n.notify("READY=1")
        wd_usec = os.getenv("WATCHDOG_USEC")
        if not wd_usec:
            return
        interval = max(1.0, int(wd_usec) / 1_000_000 / 2.0)  # half of watchdog
        log.info("Systemd watchdog enabled: interval=%.1fs", interval)
        while True:
            n.notify("WATCHDOG=1")
            await asyncio.sleep(interval)
    except Exception as e:
        log.debug("Watchdog task stopped: %s", e)

# ── Тестовая тотальная трасса (в самом конце, чтобы перекрывала странные случаи) ──
def _is_test_chat(chat_id: Optional[int]) -> bool:
    return bool(TEST_CHAT_ID and chat_id and int(chat_id) == TEST_CHAT_ID)

def tlog(chat_id: Optional[int], msg: str) -> None:
    if TRACE_TEST_CHAT and _is_test_chat(chat_id):
        log.info("TRACE: chat=%s | %s", chat_id, msg)

@router.message()
async def __trace_all_msgs(m: Message):
    try:
        if not _is_test_chat(getattr(getattr(m, "chat", None), "id", None)):
            return
        uid = getattr(getattr(m, "from_user", None), "id", None)
        t = (m.text or m.caption or "") or ""
        ents = [getattr(e, "type", None) for e in (m.entities or []) + (m.caption_entities or [])]
        tlog(m.chat.id, f"MSG mid={getattr(m,'message_id',None)} uid={uid} type={getattr(getattr(m,'chat',None),'type',None)} "
                        f"entities={ents} text={t[:200]!r}")
    except Exception as e:
        log.debug("TRACE: message hook failed: %s", e)

@router.edited_message()
async def __trace_all_edits(m: Message):
    try:
        if not _is_test_chat(getattr(getattr(m, "chat", None), "id", None)):
            return
        uid = getattr(getattr(m, "from_user", None), "id", None)
        t = (m.text or m.caption or "") or ""
        ents = [getattr(e, "type", None) for e in (m.entities or []) + (m.caption_entities or [])]
        tlog(m.chat.id, f"EDIT mid={getattr(m,'message_id',None)} uid={uid} entities={ents} text={t[:200]!r}")
    except Exception as e:
        log.debug("TRACE: edited_message hook failed: %s", e)

# ── Entry point ─────────────────────────────────────────────────────────────────
async def main():
    init_db()
    # load toggles
    val = db_get_setting("sysclean_enabled")
    state.sys_clean_enabled = (val.lower() == "true") if val is not None else ENV_DELETE_SYSTEM_MESSAGES
    val2 = db_get_setting("botlock_enabled")
    state.botlock_enabled = (val2.lower() == "true") if val2 is not None else ENV_LOCKDOWN_NONADMIN_BOTS
    val3 = db_get_setting("diag_enabled")
    state.diag_enabled = (val3.lower() == "true") if val3 is not None else False

    me = await bot.get_me()
    state.me_id = me.id
    state.me_username = (me.username or "").lower()
    log.info("Bot username: @%s (support, sys-clean=%s, botlock=%s, diag=%s)",
             me.username, state.sys_clean_enabled, state.botlock_enabled, state.diag_enabled)
    log.info(
        "ENV: SQLITE_PATH=%s DELETE_SYSTEM_MESSAGES=%s LOCKDOWN_NONADMIN_BOTS=%s AGGRESSIVE_CHANNEL_ANTILINK=%s "
        "ALLOWLIST=%s TEST_CHAT_ID=%s TRACE_TEST_CHAT=%s",
        SQLITE_PATH, ENV_DELETE_SYSTEM_MESSAGES, ENV_LOCKDOWN_NONADMIN_BOTS, AGGRESSIVE_CHANNEL_ANTILINK,
        sorted(ALLOWLIST) if ALLOWLIST else "ALL", TEST_CHAT_ID or 0, TRACE_TEST_CHAT
    )

    # background tasks
    asyncio.create_task(expirer_loop())
    asyncio.create_task(watchdog_task())

    try:
        if HAS_WD:
            await _wd.start(bot, dp, log, cmd_router, TEST_CHAT_ID, TEST_USER_ID)
    except Exception as e:
        log.warning("TESTUSER WD start error: %r", e)
    await dp.start_polling(
        bot,
        allowed_updates = ['message','edited_message','chat_member','my_chat_member','chat_join_request','callback_query'],
    )

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        pass


async def _antilink_core(m: Message):
    # DIAG
    if state.diag_enabled:
        has_l = _has_links_or_mentions(m)
        newc = (m.from_user and _removed_is_newcomer(m.from_user.id, m.chat.id)) if m.from_user else False
        log.info(
            "DIAG message: chat=%s mid=%s uid=%s is_bot=%s has_links=%s newcomer=%s text=%r",
            m.chat.id, m.message_id,
            getattr(getattr(m, "from_user", None), "id", None),
            getattr(getattr(m, "from_user", None), "is_bot", None),
            has_l, newc, (m.text or m.caption or "")[:180],
        )

    # Команды не трогаем
    if m.text and m.text.startswith('/'):
        return

    # Сообщение от канала/анона
    if getattr(m, "sender_chat", None) is not None and getattr(m.sender_chat, "id", None) is not None:
        if AGGRESSIVE_CHANNEL_ANTILINK and _has_links_or_mentions(m):
            try:
                await bot.delete_message(m.chat.id, m.message_id)
                log.info("Aggressive AntiLink: deleted CHANNEL/ANON message mid=%s chat=%s", m.message_id, m.chat.id)
            except Exception as e:
                log.info("Aggressive AntiLink: failed mid=%s in chat %s: %s", m.message_id, m.chat.id, e)
        else:
            log.info("SKIP-AntiLink: sender_chat present but no links mid=%s chat=%s", m.message_id, m.chat.id)
        return

    if not m.from_user:
        log.info("SKIP-AntiLink: no from_user (channel/anon) mid=%s chat=%s", m.message_id, m.chat.id)
        return

    uid = m.from_user.id

    # Админам можно всё
    if await is_user_admin(uid, m.chat.id):
        log.info("SKIP-AntiLink: sender is admin uid=%s chat=%s mid=%s", uid, m.chat.id, m.message_id)
        return

    # Нет ссылок/упоминаний
    if not _has_links_or_mentions(m):
        if state.diag_enabled:
            log.info("SKIP-AntiLink: no link/mention uid=%s chat=%s mid=%s", uid, m.chat.id, m.message_id)
        return

    # Обеспечить окно новичка
    nu = newcomer_until(uid, m.chat.id)
    if nu is None:
        record_approval(uid, m.chat.id)
        nu = newcomer_until(uid, m.chat.id)
    now = int(time.time())
    if not (nu and nu > now):
        log.info("SKIP-AntiLink: not newcomer uid=%s chat=%s mid=%s (until=%s now=%s)", uid, m.chat.id, m.message_id, nu, now)
        return

    try:
        await bot.delete_message(m.chat.id, m.message_id)
        log.info("AntiLink: deleted from user_id=%s chat_id=%s mid=%s", uid, m.chat.id, m.message_id)
    except Exception as e:
        log.info("AntiLink: failed delete mid=%s in chat %s: %s", m.message_id, m.chat.id, e)

# === NEWCOMER PROBE (debug-only, enable via NEWCOMER_PROBE=1 in /etc/tgbots/support.env) ===
try:
    if os.getenv("NEWCOMER_PROBE","0") == "1":
        log.info("PROBE: enabled")
        @router.message(~F.chat.type.in_({ChatType.PRIVATE}))
        async def __probe_newcomer_any_message(m: Message):
            u = m.from_user
            uid = getattr(u, "id", None)
            newcomer = (uid is not None and _removed_is_newcomer(uid, m.chat.id))
            log.info("PROBE: hit chat=%s type=%s mid=%s uid=%s newcomer=%s",
                     getattr(m.chat, "id", None), getattr(m.chat, "type", None),
                     getattr(m, "message_id", None), uid, newcomer)
            if newcomer and u and not u.is_bot:
                try:
                    await m.delete()
                    log.info("PROBE: deleted chat=%s mid=%s uid=%s", m.chat.id, m.message_id, uid)
                except Exception as e:
                    log.warning("PROBE: delete failed chat=%s mid=%s uid=%s err=%s", m.chat.id, getattr(m,'message_id',None), uid, e)
except Exception as _e:
    log.warning("PROBE: attach failed: %s", _e)

# --- TESTUSER LEAVE LOGGING (auto-inserted) -----------------------------------
# Логируем выход тестового пользователя из тестового чата:
# - событие ChatMemberUpdated, когда статус стал LEFT/KICKED
@router.chat_member()
async def _testuser_leave_logger(ev: 'ChatMemberUpdated'):
    try:
        if not (TEST_CHAT_ID and TEST_USER_ID):
            return
        chat_id = getattr(getattr(ev, "chat", None), "id", None)
        newcm = getattr(ev, "new_chat_member", None)
        user = getattr(newcm, "user", None)
        status = getattr(newcm, "status", None)
        uid = getattr(user, "id", None)
        uname = ("@" + getattr(user, "username", "")) if getattr(user, "username", None) else "-"
        if chat_id == TEST_CHAT_ID and uid == TEST_USER_ID and status in {ChatMemberStatus.LEFT, ChatMemberStatus.KICKED}:
            actor = getattr(getattr(ev, "from_user", None), "id", None)
            log.info("TESTUSER LEFT: chat=%s uid=%s %s status=%s by=%s", chat_id, uid, uname, status, actor)
    except Exception as e:
        # не валим обработку — логируем и продолжаем
        log.warning("TESTUSER LEFT log error: %r", e)
# ------------------------------------------------------------------------------

